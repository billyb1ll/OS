<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>Music Visualizer</title>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.min.js"></script>
		<style>
			body {
				font-family: Arial, sans-serif;
				display: flex;
				flex-direction: column;
				align-items: center;
				background-color: #f0f0f0; /* Lighter background */
				color: #333;
				padding-top: 20px;
			}
			#player-container {
				width: 600px; /* Match canvas width */
				background-color: #fff; /* White background for the player area */
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
				margin-bottom: 20px;
				border-radius: 8px;
				overflow: hidden; /* Keep elements contained */
			}
			#drop-area,
			#bottom-drop-area {
				border: 2px dashed #ccc;
				padding: 30px;
				width: calc(100% - 64px); /* Adjust width considering padding */
				text-align: center;
				margin: 20px auto; /* Center the drop area */
				color: #666;
				background-color: #fafafa;
				border-radius: 4px;
				display: flex;
				flex-direction: column;
				align-items: center;
			}
			#drop-area {
				padding: 50px 30px;
			}
			.file-upload-btn {
				margin-top: 15px;
				padding: 8px 16px;
				background-color: #4285f4;
				color: white;
				border: none;
				border-radius: 4px;
				cursor: pointer;
				font-size: 14px;
				display: flex;
				align-items: center;
				gap: 5px;
			}
			.file-upload-btn:hover {
				background-color: #3367d6;
			}
			.file-upload-btn::before {
				content: "üìÅ";
			}
			.file-input {
				display: none; /* Hide the native file input */
			}

			/* Test songs section */
			#test-songs-container {
				width: calc(100% - 64px);
				max-width: 800px;
				margin: 10px auto 20px;
				text-align: center;
				padding: 10px 15px 15px;
				background-color: #e8f0fe;
				border-radius: 8px;
				border: 1px solid #c9d6eb;
			}
			#test-songs-container h3 {
				margin: 5px 0 10px;
				font-size: 16px;
				color: #4285f4;
			}
			#test-songs-list {
				display: flex;
				flex-wrap: wrap;
				gap: 8px;
				justify-content: center;
				margin: 0;
				padding: 0;
			}
			.test-song-btn {
				background-color: #4285f4;
				color: white;
				border: none;
				border-radius: 30px;
				padding: 6px 12px;
				cursor: pointer;
				font-size: 13px;
				margin: 5px 0;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
				max-width: 200px;
				transition: all 0.2s ease;
			}
			.test-song-btn:hover {
				background-color: #3367d6;
				transform: scale(1.05);
			}
			.test-song-btn:before {
				content: "üéµ";
				margin-right: 5px;
			}
			#test-songs-loading {
				color: #666;
				font-style: italic;
				margin: 10px 0;
			}

			#canvas {
				display: block; /* Remove extra space below canvas */
				background-color: #000; /* Black background for visualizer */
				width: 100%; /* Make canvas fill container width */
			}
			audio {
				display: none; /* Hide the audio element */
			}
			#status {
				margin-top: 10px;
				font-style: italic;
				color: #666;
				text-align: center;
				width: 100%;
			}
			#controls-bar {
				background-color: #282828; /* Dark background for controls */
				padding: 10px 15px;
				color: #fff;
			}
			#seek-bar-container {
				padding: 5px 0;
			}
			#seek-bar {
				width: 100%;
				cursor: pointer;
				height: 5px; /* Thinner seek bar */
				appearance: none; /* Override default look */
				background: #555; /* Track background */
				border-radius: 3px;
				outline: none;
			}
			/* Style seek bar thumb */
			#seek-bar::-webkit-slider-thumb {
				appearance: none;
				width: 15px;
				height: 15px;
				background: #e50914; /* YouTube-like red */
				border-radius: 50%;
				cursor: pointer;
			}
			#seek-bar::-moz-range-thumb {
				width: 15px;
				height: 15px;
				background: #e50914;
				border-radius: 50%;
				cursor: pointer;
				border: none;
			}

			#main-controls {
				display: flex;
				align-items: center;
				gap: 15px; /* Space between control groups */
				flex-wrap: wrap;
				justify-content: space-between; /* Distribute space */
			}
			.control-group {
				display: flex;
				align-items: center;
				gap: 8px; /* Smaller gap within groups */
			}
			.left-controls,
			.right-controls {
				display: flex;
				align-items: center;
				gap: 15px;
			}
			button {
				padding: 8px 12px; /* Slightly smaller buttons */
				cursor: pointer;
				background-color: transparent; /* Transparent background */
				border: none; /* No border */
				color: #fff; /* White text/icons */
				font-size: 18px; /* Larger font size for icon-like feel */
				border-radius: 4px;
				transition: background-color 0.2s ease;
			}
			button:hover {
				background-color: rgba(255, 255, 255, 0.2); /* Subtle hover effect */
			}
			button:disabled {
				color: #888; /* Dim disabled buttons */
				background-color: transparent;
				cursor: not-allowed;
			}
			/* Specific button styles (optional, could use icons) */
			#play-pause-button::before {
				content: "‚ñ∂";
				margin-right: 5px;
			} /* Simple play icon */
			#play-pause-button.playing::before {
				content: "‚ùö‚ùö";
				margin-right: 5px;
			} /* Simple pause icon */
			#stop-audio-button::before {
				content: "‚ñ†";
				margin-right: 5px;
			} /* Simple stop icon */

			label {
				font-size: 13px;
				margin-right: 0;
				color: #ccc;
			}
			input[type="range"] {
				width: 80px; /* Smaller range inputs */
				height: 4px;
				cursor: pointer;
				appearance: none;
				background: #555;
				border-radius: 2px;
				outline: none;
			}
			input[type="range"]::-webkit-slider-thumb {
				appearance: none;
				width: 12px;
				height: 12px;
				background: #fff; /* White thumb */
				border-radius: 50%;
				cursor: pointer;
			}
			input[type="range"]::-moz-range-thumb {
				width: 12px;
				height: 12px;
				background: #fff;
				border-radius: 50%;
				cursor: pointer;
				border: none;
			}
			.value-display {
				min-width: 35px;
				text-align: right;
				font-size: 13px;
				color: #ccc;
			}
			.time-display {
				font-family: monospace;
				font-size: 14px;
				color: #fff;
			}
			#file-name {
				text-align: center;
				padding: 10px;
				font-size: 16px;
				color: #333;
				background-color: #eee; /* Light background for file name */
				border-bottom: 1px solid #ddd;
			}

			/* Performance monitoring section */
			#performance-monitor {
				width: 600px;
				background-color: #fff;
				border-radius: 8px;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
				margin-bottom: 20px;
				overflow: hidden;
			}
			#performance-header {
				background-color: #3b3b3b;
				color: white;
				padding: 15px;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}
			#performance-title {
				margin: 0;
				font-size: 18px;
			}
			.monitor-section {
				padding: 15px;
				border-bottom: 1px solid #eee;
			}
			.monitor-section h3 {
				margin-top: 0;
				font-size: 16px;
				color: #4285f4;
				margin-bottom: 10px;
			}
			.metrics-row {
				display: flex;
				flex-wrap: wrap;
				gap: 20px;
				margin-bottom: 10px;
			}
			.metric-box {
				background-color: #f9f9f9;
				border-radius: 4px;
				padding: 10px;
				min-width: 150px;
				border-left: 4px solid #4285f4;
			}
			.metric-name {
				font-size: 12px;
				color: #666;
				margin-bottom: 5px;
			}
			.metric-value {
				font-size: 16px;
				font-weight: bold;
				color: #333;
			}
			.server-metric {
				border-left-color: #4285f4; /* Blue for server metrics */
			}
			.client-metric {
				border-left-color: #0f9d58; /* Green for client metrics */
			}
			.network-metric {
				border-left-color: #db4437; /* Red for network metrics */
			}
			.metric-trend {
				font-size: 12px;
				color: #888;
				margin-top: 3px;
				display: flex;
				align-items: center;
			}

			.trend-up {
				color: #db4437;
			}

			.trend-down {
				color: #0f9d58;
			}

			.trend-stable {
				color: #888;
			}

			.trend-up::before {
				content: "‚ñ≤";
				margin-right: 3px;
			}

			.trend-down::before {
				content: "‚ñº";
				margin-right: 3px;
			}

			.trend-stable::before {
				content: "‚ñ†";
				margin-right: 3px;
			}

			.metric-detail {
				font-size: 11px;
				color: #888;
				margin-top: 3px;
			}

			/* Settings panel */
			#visualization-settings {
				width: 800px;
				background-color: #fff;
				border-radius: 8px;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
				margin-bottom: 20px;
				overflow: hidden;
			}
			#settings-header {
				background-color: #3b3b3b;
				color: white;
				padding: 15px;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}
			#settings-title {
				margin: 0;
				font-size: 18px;
			}
			.settings-section {
				padding: 15px;
				border-bottom: 1px solid #eee;
			}
			.settings-section h3 {
				margin-top: 0;
				font-size: 16px;
				color: #4285f4;
				margin-bottom: 10px;
			}
			.setting-row {
				display: flex;
				flex-direction: row;
				align-items: center;
				justify-content: space-between;
				margin-bottom: 15px;
				padding: 10px;
				background-color: #f9f9f9;
				border-radius: 4px;
			}
			.setting-label {
				display: flex;
				flex-direction: column;
			}
			.setting-name {
				font-weight: bold;
				color: #333;
				margin-bottom: 4px;
			}
			.setting-description {
				font-size: 12px;
				color: #666;
			}
			.setting-controls {
				display: flex;
				align-items: center;
				gap: 10px;
			}
			.setting-controls input[type="range"] {
				width: 120px;
			}
			.setting-controls button {
				background-color: #4285f4;
				color: white;
				border: none;
				padding: 8px 12px;
				border-radius: 4px;
				cursor: pointer;
				font-size: 14px;
			}
			.setting-controls button:hover {
				background-color: #3367d6;
			}
			.setting-controls button:disabled {
				background-color: #ccc;
				cursor: not-allowed;
			}
			.color-button {
				width: 30px;
				height: 30px;
				border-radius: 50%;
				cursor: pointer;
				border: 2px solid transparent;
			}
			.color-button.active {
				border: 2px solid white;
				box-shadow: 0 0 0 2px black;
			}
			.color-button.blue-theme {
				background: linear-gradient(to bottom, #4285f4, #0d47a1);
			}
			.color-button.red-theme {
				background: linear-gradient(to bottom, #db4437, #b71c1c);
			}
			.color-button.green-theme {
				background: linear-gradient(to bottom, #0f9d58, #1b5e20);
			}
			.color-button.rainbow-theme {
				background: linear-gradient(
					to right,
					red,
					orange,
					yellow,
					green,
					blue,
					indigo,
					violet
				);
			}
			.network-simulator {
				display: flex;
				flex-direction: column;
				gap: 10px;
			}
			.delay-controls {
				display: flex;
				gap: 10px;
				align-items: center;
			}

			#bottom-drop-area {
				width: 80%; /* Adjust width as needed */
				max-width: 800px; /* Match player width */
				margin: 30px auto; /* Add space above and center */
			}

			/* Flex container for player and performance monitor */
			.flex-container {
				display: flex;
				flex-direction: row;
				gap: 20px;
				width: 100%;
				max-width: 1250px;
				margin: 0 auto;
				justify-content: center;
				flex-wrap: wrap;
			}

			#player-container,
			#performance-monitor {
				flex: 1;
				min-width: 320px;
				max-width: 600px;
			}

			/* Enhanced impact bar styles */
			.impact-bar {
				height: 12px;
				background: linear-gradient(to right, #4285f4, #0d47a1);
				border-radius: 6px;
				transition: width 0.5s ease-in-out;
			}

			.impact-label {
				min-width: 150px;
				font-weight: bold;
				color: #444;
			}

			.impact-value {
				min-width: 80px;
				text-align: right;
				font-size: 13px;
				color: #555;
				font-weight: bold;
			}

			/* Make impact bars colorful based on impact level */
			#resolution-impact {
				background: linear-gradient(to right, #42c6ff, #0d8aff);
			}

			#smoothing-impact {
				background: linear-gradient(to right, #42ff8e, #0d8a4f);
			}

			#chunk-impact {
				background: linear-gradient(to right, #ffdd42, #ff8e0d);
			}

			#network-impact {
				background: linear-gradient(to right, #ff5e42, #d10d0d);
			}

			#viz-style-impact {
				background: linear-gradient(to right, #d442ff, #8e0dff);
			}

			/* Update button styles */
			.impact-test-btn {
				margin-top: 10px;
				background: linear-gradient(to bottom, #4285f4, #2a56c6);
				transition: all 0.3s ease;
				width: 100%;
			}

			.impact-test-btn:hover {
				background: linear-gradient(to bottom, #5294ff, #3367d6);
				transform: translateY(-2px);
			}

			/* Responsive Design */
			@media (max-width: 850px) {
				/* Adjust breakpoint as needed */
				#player-container,
				#performance-monitor,
				#visualization-settings {
					width: 95%; /* Use more width on smaller screens */
				}
				#main-controls {
					flex-direction: column; /* Stack controls vertically */
					align-items: flex-start; /* Align items to the start */
					gap: 10px;
				}
				.left-controls,
				.right-controls {
					width: 100%; /* Make control groups take full width */
					justify-content: space-between; /* Space out items within groups */
				}
				.right-controls {
					flex-direction: column; /* Stack right controls */
					align-items: flex-start;
					gap: 10px;
				}
				.control-group {
					width: 100%;
					justify-content: space-between;
				}
				input[type="range"] {
					width: 150px; /* Give sliders more space */
				}
				#bottom-drop-area {
					width: 90%;
				}
				.file-upload-btn {
					margin-top: 15px;
					padding: 10px 20px;
					font-size: 16px;
				}
				.metrics-row {
					flex-direction: column;
					gap: 10px;
				}
				.metric-box {
					width: calc(100% - 20px);
				}
				.setting-row {
					flex-direction: column;
					align-items: flex-start;
					gap: 10px;
				}
				.setting-controls {
					width: 100%;
					justify-content: space-between;
				}
				.setting-controls input[type="range"] {
					width: 100%;
				}
			}

			@media (max-width: 480px) {
				/* Further adjustments for very small screens */
				h1 {
					font-size: 1.5em;
				}
				#player-container,
				#performance-monitor,
				#visualization-settings {
					width: 100%;
					border-radius: 0;
					box-shadow: none;
				}
				#controls-bar,
				#settings-header,
				#performance-header {
					padding: 10px;
				}
				.left-controls {
					flex-direction: column; /* Stack play/stop/time */
					align-items: flex-start;
					gap: 10px;
				}
				.time-display {
					align-self: flex-start; /* Align time to the start */
				}
				button {
					padding: 10px 15px; /* Slightly larger touch targets */
				}
				label {
					font-size: 12px;
				}
				.value-display {
					font-size: 12px;
				}
				#bottom-drop-area {
					width: 95%;
					padding: 20px;
				}
				/* Make upload button more prominent on mobile */
				.file-upload-btn {
					width: 80%;
					padding: 12px 10px;
					font-size: 16px;
					margin-top: 20px;
				}
				.setting-row {
					padding: 10px 5px;
				}
			}

			footer {
				margin-top: 40px; /* Add space above the footer */
				padding: 15px;
				text-align: center;
				font-size: 12px;
				color: #888;
				width: 100%;
			}

			/* New styles for parameter impact monitor */
			.impact-container {
				display: flex;
				flex-direction: column;
				gap: 10px;
			}
			.impact-row {
				display: flex;
				justify-content: space-between;
				align-items: center;
			}
			.impact-bar-container {
				flex-grow: 1;
				background-color: #eee;
				border-radius: 4px;
				overflow: hidden;
				margin: 0 10px;
			}
			.impact-bar {
				height: 10px;
				background-color: #4285f4;
			}
			.impact-description {
				font-size: 12px;
				color: #666;
				margin-bottom: 5px;
			}
			.impact-test-btn {
				background-color: #4285f4;
				color: white;
				border: none;
				padding: 8px 12px;
				border-radius: 4px;
				cursor: pointer;
				font-size: 14px;
			}
			.impact-test-btn:hover {
				background-color: #3367d6;
			}
			#impact-test-result {
				margin-top: 10px;
				font-style: italic;
				color: #666;
			}
		</style>
	</head>
	<body>
		<h1>Music Visualizer</h1>
		<h5>Recomended: Use Chrome or Firefox</h5>

		<div id="drop-area">
			<p>Drag and drop an MP3 file here</p>
			<label class="file-upload-btn">
				<input type="file" class="file-input" id="file-upload" accept="audio/*" />
				Upload File
			</label>
		</div>

		<div id="test-songs-container">
			<h3>Available Test Songs</h3>
			<div id="test-songs-list">
				<!-- Test song buttons will be dynamically added here -->
			</div>
			<div id="test-songs-loading">Loading test songs...</div>
		</div>

		<!-- New flex container to hold player and performance monitor side by side -->
		<div class="flex-container">
			<div id="player-container">
				<h2 id="file-name">No file playing</h2>
				<!-- File name heading -->
				<canvas id="canvas" width="600" height="300"></canvas>
				<!-- Adjusted width for side-by-side layout -->
				<div id="controls-bar">
					<div id="seek-bar-container">
						<input
							type="range"
							id="seek-bar"
							min="0"
							max="100"
							step="0.1"
							value="0" />
					</div>
					<div id="main-controls">
						<div class="left-controls">
							<button id="play-pause-button" disabled>Play</button>
							<button id="stop-audio-button" disabled>Stop</button>
							<span class="time-display" id="time-display">00:00 / 00:00</span>
						</div>
						<div class="right-controls">
							<div class="control-group">
								<label for="volume-control">Volume:</label>
								<input
									type="range"
									id="volume-control"
									min="0"
									max="1"
									step="0.01"
									value="1" />
								<span class="value-display" id="volume-display">100%</span>
							</div>
							<div class="control-group">
								<label for="speed-control">Speed:</label>
								<input
									type="range"
									id="speed-control"
									min="0.5"
									max="2"
									step="0.1"
									value="1" />
								<span class="value-display" id="speed-display">1.0x</span>
							</div>
							<button id="stop-button">Stop Processing</button>
						</div>
					</div>
				</div>
			</div>

			<!-- Performance Monitoring Panel - now next to the player -->
			<div id="performance-monitor">
				<div id="performance-header">
					<h2 id="performance-title">Performance Monitor</h2>
				</div>

				<div class="monitor-section">
					<h3>Server Performance</h3>
					<div class="metrics-row">
						<div class="metric-box server-metric">
							<div class="metric-name">CPU Usage</div>
							<div class="metric-value" id="cpu-usage">0%</div>
							<div class="metric-trend" id="cpu-trend"></div>
						</div>
						<div class="metric-box server-metric">
							<div class="metric-name">Memory Usage</div>
							<div class="metric-value" id="memory-usage">0 MB</div>
							<div class="metric-trend" id="memory-trend"></div>
						</div>
					</div>
					<div class="metrics-row">
						<div class="metric-box server-metric">
							<div class="metric-name">Avg. Processing Time</div>
							<div class="metric-value" id="processing-time">0 ms</div>
							<div class="metric-detail" id="processing-time-detail">
								Min: 0ms | Max: 0ms
							</div>
						</div>
						<div class="metric-box server-metric">
							<div class="metric-name">Total Chunks Processed</div>
							<div class="metric-value" id="chunks-processed">0</div>
							<div class="metric-detail" id="processing-rate">0 chunks/sec</div>
						</div>
					</div>
				</div>

				<div class="monitor-section">
					<h3>Network Performance</h3>
					<div class="metrics-row">
						<div class="metric-box network-metric">
							<div class="metric-name">Network Latency</div>
							<div class="metric-value" id="network-latency">0 ms</div>
							<div class="metric-detail" id="latency-detail">Min: 0ms | Max: 0ms</div>
						</div>
						<div class="metric-box network-metric">
							<div class="metric-name">Data Received</div>
							<div class="metric-value" id="data-received">0 KB</div>
							<div class="metric-detail" id="bandwidth">0 KB/s</div>
						</div>
					</div>
					<div class="metrics-row">
						<div class="metric-box network-metric">
							<div class="metric-name">Packets Received</div>
							<div class="metric-value" id="packets-received">0</div>
							<div class="metric-detail" id="packets-rate">0/sec</div>
						</div>
						<div class="metric-box network-metric">
							<div class="metric-name">Packets Lost</div>
							<div class="metric-value" id="packets-lost">0</div>
							<div class="metric-detail" id="packet-loss-rate">0%</div>
						</div>
					</div>
				</div>

				<div class="monitor-section">
					<h3>Client Performance</h3>
					<div class="metrics-row">
						<div class="metric-box client-metric">
							<div class="metric-name">Frame Rate</div>
							<div class="metric-value" id="frame-rate">0 FPS</div>
						</div>
						<div class="metric-box client-metric">
							<div class="metric-name">Rendering Time</div>
							<div class="metric-value" id="render-time">0 ms</div>
						</div>
					</div>
					<div class="metrics-row">
						<div class="metric-box client-metric">
							<div class="metric-name">Memory Usage</div>
							<div class="metric-value" id="client-memory">0 MB</div>
						</div>
						<div class="metric-box client-metric">
							<div class="metric-name">Smoothness</div>
							<div class="metric-value" id="smoothness">100%</div>
						</div>
					</div>
				</div>

				<!-- Parameter Impact Monitor moved here -->
				<div class="monitor-section">
					<h3>Parameter Impact</h3>
					<div class="impact-container">
						<div class="impact-row">
							<div class="impact-label">Resolution Impact</div>
							<div class="impact-bar-container">
								<div class="impact-bar" id="resolution-impact" style="width: 20%"></div>
								<span class="impact-value">Low</span>
							</div>
						</div>

						<div class="impact-row">
							<div class="impact-label">Smoothing Impact</div>
							<div class="impact-bar-container">
								<div class="impact-bar" id="smoothing-impact" style="width: 10%"></div>
								<span class="impact-value">Very Low</span>
							</div>
						</div>

						<div class="impact-row">
							<div class="impact-label">Chunk Size Impact</div>
							<div class="impact-bar-container">
								<div class="impact-bar" id="chunk-impact" style="width: 70%"></div>
								<span class="impact-value">High</span>
							</div>
						</div>

						<div class="impact-row">
							<div class="impact-label">Network Delay Impact</div>
							<div class="impact-bar-container">
								<div class="impact-bar" id="network-impact" style="width: 90%"></div>
								<span class="impact-value">Very High</span>
							</div>
						</div>

						<div class="impact-row">
							<div class="impact-label">Viz Style Impact</div>
							<div class="impact-bar-container">
								<div class="impact-bar" id="viz-style-impact" style="width: 40%"></div>
								<span class="impact-value">Medium</span>
							</div>
						</div>
					</div>

					<button id="run-impact-test" class="impact-test-btn">
						Run Impact Test
					</button>
					<div id="impact-test-result">See which parameter has the most impact</div>
				</div>
			</div>
		</div>

		<!-- New Visualization Settings Panel -->
		<div id="visualization-settings">
			<div id="settings-header">
				<h2 id="settings-title">Visualization Settings</h2>
			</div>

			<div class="settings-section">
				<h3>Visual Parameters</h3>

				<div class="setting-row">
					<div class="setting-label">
						<span class="setting-name">Resolution</span>
						<span class="setting-description"
							>Adjust the resolution of the visualizer</span
						>
					</div>
					<div class="setting-controls">
						<input
							type="range"
							id="resolution-control"
							min="64"
							max="512"
							step="32"
							value="256" />
						<span class="value-display" id="resolution-display">256 px</span>
						<button id="resolution-low">Low</button>
						<button id="resolution-high">High</button>
					</div>
				</div>

				<div class="setting-row">
					<div class="setting-label">
						<span class="setting-name">Color Scheme</span>
						<span class="setting-description"
							>Choose visualization color palette</span
						>
					</div>
					<div class="setting-controls">
						<div class="color-button blue-theme active" data-theme="blue"></div>
						<div class="color-button red-theme" data-theme="red"></div>
						<div class="color-button green-theme" data-theme="green"></div>
						<div class="color-button rainbow-theme" data-theme="rainbow"></div>
						<button id="custom-color-btn">Custom Color</button>
						<input type="color" id="color-picker" value="#4285f4" />
					</div>
				</div>

				<div class="setting-row">
					<div class="setting-label">
						<span class="setting-name">Background Color</span>
						<span class="setting-description">Set the visualization background</span>
					</div>
					<div class="setting-controls">
						<input type="color" id="bg-color-picker" value="#000000" />
						<span class="value-display" id="bg-color-display">#000000</span>
					</div>
				</div>

				<div class="setting-row">
					<div class="setting-label">
						<span class="setting-name">Smoothing</span>
						<span class="setting-description">Control visualization smoothness</span>
					</div>
					<div class="setting-controls">
						<input
							type="range"
							id="smoothing-control"
							min="0"
							max="0.9"
							step="0.1"
							value="0.5" />
						<span class="value-display" id="smoothing-display">0.5</span>
					</div>
				</div>

				<div class="setting-row">
					<div class="setting-label">
						<span class="setting-name">Bar Width</span>
						<span class="setting-description"
							>Adjust the width of visualizer bars</span
						>
					</div>
					<div class="setting-controls">
						<input
							type="range"
							id="bar-width-control"
							min="1"
							max="8"
							step="1"
							value="3" />
						<span class="value-display" id="bar-width-display">3px</span>
					</div>
				</div>

				<div class="setting-row">
					<div class="setting-label">
						<span class="setting-name">Visualization Style</span>
						<span class="setting-description">Choose visualization style</span>
					</div>
					<div class="setting-controls">
						<select id="viz-style">
							<option value="bars">Bars</option>
							<option value="wave">Waveform</option>
							<option value="circle">Circular</option>
						</select>
					</div>
				</div>
			</div>

			<div class="settings-section">
				<h3>Performance Parameters</h3>

				<div class="setting-row">
					<div class="setting-label">
						<span class="setting-name">Chunk Size</span>
						<span class="setting-description">Set audio processing chunk size</span>
					</div>
					<div class="setting-controls">
						<button id="chunk-small">Small</button>
						<button id="chunk-medium" class="active">Medium</button>
						<button id="chunk-large">Large</button>
					</div>
				</div>

				<div class="setting-row">
					<div class="setting-label">
						<span class="setting-name">Network Simulation</span>
						<span class="setting-description">Simulate network conditions</span>
					</div>
					<div class="setting-controls network-simulator">
						<div class="delay-controls">
							<label for="network-delay">Delay (ms):</label>
							<input
								type="range"
								id="network-delay"
								min="0"
								max="1000"
								step="50"
								value="0" />
							<span class="value-display" id="delay-display">0ms</span>
						</div>
						<div class="delay-controls">
							<label for="packet-loss">Packet Loss (%):</label>
							<input
								type="range"
								id="packet-loss"
								min="0"
								max="50"
								step="5"
								value="0" />
							<span class="value-display" id="loss-display">0%</span>
						</div>
						<button id="apply-network">Apply</button>
						<button id="reset-network">Reset</button>
					</div>
				</div>
			</div>
		</div>

		<div id="status">Ready</div>
		<audio id="audio"></audio>

		<!-- Bottom drop area for uploading additional songs -->
		<div id="bottom-drop-area">
			<p>Upload more music</p>
			<label class="file-upload-btn">
				<input
					type="file"
					class="file-input"
					id="bottom-file-upload"
					accept="audio/*" />
				Upload File
			</label>
		</div>

		<footer>
			Powered by
			<a href="https://github.com/billyb1ll/OS" label="github">Billy</a
			>@Ratatatamoth group - 2025
		</footer>

		<script>
						const dropArea = document.getElementById("drop-area");
						const bottomDropArea = document.getElementById("bottom-drop-area");
						const canvas = document.getElementById("canvas");
						const ctx = canvas.getContext("2d");
						const audio = document.getElementById("audio");
						const fileNameDisplay = document.getElementById("file-name");
						const statusDisplay = document.getElementById("status");
						const stopButton = document.getElementById("stop-button");
						const playPauseButton = document.getElementById("play-pause-button");
						const stopAudioButton = document.getElementById("stop-audio-button");
						const volumeControl = document.getElementById("volume-control");
						const volumeDisplay = document.getElementById("volume-display");
						const speedControl = document.getElementById("speed-control");
						const speedDisplay = document.getElementById("speed-display");
						const timeDisplay = document.getElementById("time-display");
						const seekBar = document.getElementById("seek-bar");
						const fileUpload = document.getElementById("file-upload");
						const bottomFileUpload = document.getElementById("bottom-file-upload");
						const testSongsContainer = document.getElementById("test-songs-container");
						const testSongsList = document.getElementById("test-songs-list");
						const testSongsLoading = document.getElementById("test-songs-loading");

						// Visualizer settings
						const resolutionControl = document.getElementById("resolution-control");
						const resolutionDisplay = document.getElementById("resolution-display");
						const resolutionLowButton = document.getElementById("resolution-low");
						const resolutionHighButton = document.getElementById("resolution-high");
						const smoothingControl = document.getElementById("smoothing-control");
						const smoothingDisplay = document.getElementById("smoothing-display");
						const barWidthControl = document.getElementById("bar-width-control");
						const barWidthDisplay = document.getElementById("bar-width-display");
						const colorButtons = document.querySelectorAll(".color-button");
						const chunkSizeButtons = document.querySelectorAll(
							"#chunk-small, #chunk-medium, #chunk-large"
						);

						// Network simulation
						const networkDelaySlider = document.getElementById("network-delay");
						const delayDisplay = document.getElementById("delay-display");
						const packetLossSlider = document.getElementById("packet-loss");
						const lossDisplay = document.getElementById("loss-display");
						const applyNetworkButton = document.getElementById("apply-network");
						const resetNetworkButton = document.getElementById("reset-network");

						// Performance metrics elements
						const cpuUsageElement = document.getElementById("cpu-usage");
						const memoryUsageElement = document.getElementById("memory-usage");
						const processingTimeElement = document.getElementById("processing-time");
						const chunksProcessedElement = document.getElementById("chunks-processed");
						const frameRateElement = document.getElementById("frame-rate");
						const renderTimeElement = document.getElementById("render-time");
						const clientMemoryElement = document.getElementById("client-memory");
						const smoothnessElement = document.getElementById("smoothness");
						const networkLatencyElement = document.getElementById("network-latency");
						const dataReceivedElement = document.getElementById("data-received");
						const packetsReceivedElement = document.getElementById("packets-received");
						const packetsLostElement = document.getElementById("packets-lost");

						// Initialize socket.io connection
						const socket = io();

						// App state variables
						let audioContext, analyser, dataArray;
						let isProcessingRemote = false;
						let currentTaskId = null;
						let updateTimeInterval = null;
						let animationFrameId = null;
						let serverChunks = [];
						let serverMetrics = {
							cpuUsage: 0,
							memoryUsage: 0,
							processingTimes: [],
							chunksProcessed: 0,
							totalDataReceived: 0,
						};
						let clientMetrics = {
							frameRates: [],
							renderTimes: [],
							lastFrameTime: 0,
							packetLatencies: [],
							packetsReceived: 0,
							packetsLost: 0,
							lostPacketIds: new Set(),
						};
						let visualizerSettings = {
							resolution: 256,
							smoothingFactor: 0.5,
							barWidth: 3,
							colorScheme: "blue",
							chunkSize: "medium",
							networkDelay: 0,
							packetLoss: 0,
						};

						// Settings for color schemes
						const colorSchemes = {
							blue: {
								gradient: function (ctx, height, barHeight) {
									const gradient = ctx.createLinearGradient(
										0,
										height,
										0,
										height - barHeight
									);
									gradient.addColorStop(0, "#4285f4");
									gradient.addColorStop(1, "#a2c4ff");
									return gradient;
								},
								solid: "#4285f4",
							},
							red: {
								gradient: function (ctx, height, barHeight) {
									const gradient = ctx.createLinearGradient(
										0,
										height,
										0,
										height - barHeight
									);
									gradient.addColorStop(0, "#db4437");
									gradient.addColorStop(1, "#ff8a80");
									return gradient;
								},
								solid: "#db4437",
							},
							green: {
								gradient: function (ctx, height, barHeight) {
									const gradient = ctx.createLinearGradient(
										0,
										height,
										0,
										height - barHeight
									);
									gradient.addColorStop(0, "#0f9d58");
									gradient.addColorStop(1, "#a5d6a7");
									return gradient;
								},
								solid: "#0f9d58",
							},
							rainbow: {
								gradient: function (ctx, height, barHeight, i, totalBars) {
									const gradient = ctx.createLinearGradient(
										0,
										height,
										0,
										height - barHeight
									);
									const hue = (i / totalBars) * 360;
									gradient.addColorStop(0, `hsl(${hue}, 100%, 50%)`);
									gradient.addColorStop(1, `hsl(${hue}, 100%, 75%)`);
									return gradient;
								},
								solid: function (i, totalBars) {
									const hue = (i / totalBars) * 360;
									return `hsl(${hue}, 100%, 50%)`;
								},
							},
						};

						// Audio playback controls
						playPauseButton.addEventListener("click", togglePlayPause);
						stopAudioButton.addEventListener("click", stopAudio);
						volumeControl.addEventListener("input", updateVolume);
						speedControl.addEventListener("input", updateSpeed);

						// Settings controls listeners
						resolutionControl.addEventListener("input", updateResolution);
						resolutionLowButton.addEventListener("click", () => {
							resolutionControl.value = 128;
							updateResolution();
						});
						resolutionHighButton.addEventListener("click", () => {
							resolutionControl.value = 512;
							updateResolution();
						});
						smoothingControl.addEventListener("input", updateSmoothing);
						barWidthControl.addEventListener("input", updateBarWidth);

						// Color scheme selection
						colorButtons.forEach((button) => {
							button.addEventListener("click", (e) => {
								const theme = e.target.dataset.theme;
								if (theme) {
									setColorScheme(theme);
									colorButtons.forEach((btn) => btn.classList.remove("active"));
									e.target.classList.add("active");
								}
							});
						});

						// Chunk size selection
						chunkSizeButtons.forEach((button) => {
							button.addEventListener("click", (e) => {
								chunkSizeButtons.forEach((btn) => btn.classList.remove("active"));
								e.target.classList.add("active");
								visualizerSettings.chunkSize = e.target.id.replace("chunk-", "");
							});
						});

						// Network simulation controls
						networkDelaySlider.addEventListener("input", () => {
							visualizerSettings.networkDelay = parseInt(networkDelaySlider.value);
							delayDisplay.textContent = `${visualizerSettings.networkDelay}ms`;
						});

						packetLossSlider.addEventListener("input", () => {
							visualizerSettings.packetLoss = parseInt(packetLossSlider.value);
							lossDisplay.textContent = `${visualizerSettings.packetLoss}%`;
						});

						applyNetworkButton.addEventListener("click", () => {
							// Network settings already stored in visualizerSettings
							statusDisplay.textContent = `Network simulation updated: ${visualizerSettings.networkDelay}ms delay, ${visualizerSettings.packetLoss}% packet loss`;
						});

						resetNetworkButton.addEventListener("click", () => {
							visualizerSettings.networkDelay = 0;
							visualizerSettings.packetLoss = 0;
							networkDelaySlider.value = 0;
							packetLossSlider.value = 0;
							delayDisplay.textContent = "0ms";
							lossDisplay.textContent = "0%";
							statusDisplay.textContent = "Network simulation reset";
						});

						// Load test songs dynamically
						async function loadTestSongs() {
							try {
								const response = await fetch("/test-songs");
								const songs = await response.json();

								if (songs.length === 0) {
									testSongsLoading.textContent = "No test songs available";
									return;
								}

								testSongsLoading.style.display = "none";

								songs.forEach((song) => {
									const button = document.createElement("button");
									button.className = "test-song-btn";
									button.textContent = song.name;
									button.addEventListener("click", () => {
										// Reset audio if already playing
										stopAudio();

										// Update UI
										fileNameDisplay.textContent = `Playing: ${song.name}`;
										statusDisplay.textContent = "Loading test song...";

										// Set audio source
										audio.src = song.url;

										// Enable controls
										playPauseButton.disabled = false;
										stopAudioButton.disabled = false;

										// Initialize audio context before playing
										if (!audioContext) {
											initAudioContext();
										} else {
											// If context already exists but was disconnected, reconnect it
											try {
												if (audioContext.state === "suspended") {
													audioContext.resume();
												}
											} catch (e) {
												console.log("Audio context resume error:", e);
												// If there's an error with existing context, create a new one
												initAudioContext();
											}
										}

										// Wait a bit to ensure resources are loaded, then play
										setTimeout(() => {
											audio
												.play()
												.then(() => {
													statusDisplay.textContent = "Playing test song";
												})
												.catch((err) => {
													console.error("Error playing audio:", err);
													statusDisplay.textContent = `Error: ${err.message}`;
												});
										}, 100);
									});
									testSongsList.appendChild(button);
								});
							} catch (error) {
								console.error("Error loading test songs:", error);
								testSongsLoading.textContent = `Error: ${error.message}`;
							}
						}

						loadTestSongs();

						// Update seek bar as audio plays
						audio.addEventListener("timeupdate", () => {
							if (!audio.duration) return;
							seekBar.value = (audio.currentTime / audio.duration) * 100;
						});

						// Seek to position when user interacts with seek bar
						seekBar.addEventListener("input", () => {
							if (!audio.duration) return;
							audio.currentTime = (seekBar.value / 100) * audio.duration;
						});

						function togglePlayPause() {
							if (audio.paused) {
								audio.play();
								playPauseButton.textContent = "Pause";
								playPauseButton.classList.add("playing");
							} else {
								audio.pause();
								playPauseButton.textContent = "Play";
								playPauseButton.classList.remove("playing");
							}
						}

						function stopAudio() {
							audio.pause();
							audio.currentTime = 0;
							playPauseButton.textContent = "Play";
							playPauseButton.classList.remove("playing");

							// Reset seek bar position
							seekBar.value = 0;
						}

						function updateVolume() {
							audio.volume = volumeControl.value;
							volumeDisplay.textContent = `${Math.round(volumeControl.value * 100)}%`;
						}

						function updateSpeed() {
							audio.playbackRate = speedControl.value;
							speedDisplay.textContent = `${speedControl.value}x`;
						}

						function updateTimeDisplay() {
							if (!audio.duration) return;

							const currentMinutes = Math.floor(audio.currentTime / 60);
							const currentSeconds = Math.floor(audio.currentTime % 60);
							const totalMinutes = Math.floor(audio.duration / 60);
							const totalSeconds = Math.floor(audio.duration % 60);

							timeDisplay.textContent = `${currentMinutes
								.toString()
								.padStart(2, "0")}:${currentSeconds
								.toString()
								.padStart(2, "0")} / ${totalMinutes
								.toString()
								.padStart(2, "0")}:${totalSeconds.toString().padStart(2, "0")}`;
						}

						// Visualizer setting update functions
						function updateResolution() {
							visualizerSettings.resolution = parseInt(resolutionControl.value);
							resolutionDisplay.textContent = `${visualizerSettings.resolution} px`;

							// If we have a running analyser, update its settings
							if (analyser) {
								analyser.fftSize = visualizerSettings.resolution * 2; // FFT size must be 2x resolution
								dataArray = new Uint8Array(analyser.frequencyBinCount);
							}
						}

						function updateSmoothing() {
							visualizerSettings.smoothingFactor = parseFloat(smoothingControl.value);
							smoothingDisplay.textContent =
								visualizerSettings.smoothingFactor.toFixed(1);

							// If we have a running analyser, update its settings
							if (analyser) {
								analyser.smoothingTimeConstant = visualizerSettings.smoothingFactor;
							}
						}

						function updateBarWidth() {
							visualizerSettings.barWidth = parseInt(barWidthControl.value);
							barWidthDisplay.textContent = `${visualizerSettings.barWidth}px`;
						}

						function setColorScheme(scheme) {
							visualizerSettings.colorScheme = scheme;
						}

						// Set up audio events
						audio.addEventListener("play", () => {
							playPauseButton.textContent = "Pause";
							playPauseButton.classList.add("playing");
						});

						audio.addEventListener("pause", () => {
							playPauseButton.textContent = "Play";
							playPauseButton.classList.remove("playing");
						});

						audio.addEventListener("ended", () => {
							playPauseButton.textContent = "Play";
							playPauseButton.classList.remove("playing");
							// Reset seek bar visually
							if (seekBar) {
								seekBar.value = 0;
							}
						});

						audio.addEventListener("loadedmetadata", () => {
							playPauseButton.disabled = false;
							stopAudioButton.disabled = false;
							updateTimeDisplay();

							// Set up interval for updating time display
							if (updateTimeInterval) clearInterval(updateTimeInterval);
							updateTimeInterval = setInterval(updateTimeDisplay, 1000);
						});

						// Socket connection events
						socket.on("connect", () => {
							console.log("Connected to server");
							statusDisplay.textContent = "Connected to server";
						});

						socket.on("disconnect", () => {
							console.log("Disconnected from server");
							statusDisplay.textContent = "Disconnected from server";
							stopButton.disabled = true;
						});

						// Handle incoming audio chunks from server
						socket.on("audio_chunk", (chunkData) => {
							// Apply artificial network delay if set
							if (visualizerSettings.networkDelay > 0) {
								setTimeout(() => processChunk(chunkData), visualizerSettings.networkDelay);
							} else {
								processChunk(chunkData);
							}
						});

						function processChunk(chunkData) {
							// Simulate packet loss if enabled
							if (visualizerSettings.packetLoss > 0) {
								const lossRandom = Math.random() * 100;
								if (lossRandom < visualizerSettings.packetLoss) {
									// Simulated packet loss
									clientMetrics.packetsLost++;
									clientMetrics.lostPacketIds.add(chunkData.metrics.chunk_index);
									packetsLostElement.textContent = clientMetrics.packetsLost;
									return; // Skip processing this chunk
								}
							}

							// Track network metrics
							clientMetrics.packetsReceived++;
							clientMetrics.packetLatencies.push(
								Date.now() - chunkData.metrics.timestamp * 1000
							);
							serverMetrics.totalDataReceived += JSON.stringify(chunkData).length;

							// Store chunk data for visualization
							serverChunks[chunkData.metrics.chunk_index] = chunkData.data;

							// Update server metrics
							serverMetrics.chunksProcessed++;
							serverMetrics.cpuUsage = chunkData.metrics.cpu_usage_after;
							serverMetrics.memoryUsage = chunkData.metrics.memory_usage_after;
							serverMetrics.processingTimes.push(chunkData.metrics.processing_time_ms);

							// Update metrics display
							updateMetricsDisplay();

							// Update metrics on screen
							packetsReceivedElement.textContent = clientMetrics.packetsReceived;
							chunksProcessedElement.textContent = serverMetrics.chunksProcessed;

							// Calculate average latency
							if (clientMetrics.packetLatencies.length > 0) {
								const avgLatency =
									clientMetrics.packetLatencies.reduce((sum, val) => sum + val, 0) /
									clientMetrics.packetLatencies.length;
								networkLatencyElement.textContent = `${Math.round(avgLatency)} ms`;
							}

							// Calculate data received in KB
							dataReceivedElement.textContent = `${Math.round(
								serverMetrics.totalDataReceived / 1024
							)} KB`;
						}

						socket.on("processing_complete", () => {
							console.log("Audio processing complete");
							statusDisplay.textContent = "Audio processing complete";
							isProcessingRemote = false;
							stopButton.disabled = true;
						});

						socket.on("processing_stopped", () => {
							console.log("Audio processing stopped");
							statusDisplay.textContent = "Processing stopped by user";
							isProcessingRemote = false;
							stopButton.disabled = true;
						});

						// Stop button event listener
						stopButton.addEventListener("click", async () => {
							if (!isProcessingRemote || !currentTaskId) return;

							try {
								statusDisplay.textContent = "Stopping processing...";

								const response = await fetch("/stop-processing", {
									method: "POST",
									headers: {
										"Content-Type": "application/json",
									},
									body: JSON.stringify({ task_id: currentTaskId }),
								});

								const result = await response.json();

								if (!response.ok) {
									throw new Error(result.error || "Failed to stop processing");
								}

								console.log("Stop request sent successfully");
								// Wait for the server to confirm via socket
							} catch (error) {
								console.error("Error stopping processing:", error);
								statusDisplay.textContent = `Error: ${error.message}`;
							}
						});

						// Drag and drop event listeners for TOP area
						dropArea.addEventListener("dragover", (event) => {
							event.preventDefault();
							dropArea.style.backgroundColor = "#f0f0f0";
						});

						dropArea.addEventListener("dragleave", () => {
							dropArea.style.backgroundColor = "";
						});

						dropArea.addEventListener("drop", handleDrop);

						async function handleDrop(event) {
							event.preventDefault();
							// Reset background
							dropArea.style.backgroundColor = "";

							// Hide the TOP drop area after a file is dropped
							dropArea.style.display = "none";

							const file = event.dataTransfer.files[0];
							if (!file) return;

							// Display the name of the file
							fileNameDisplay.textContent = `Processing: ${file.name}`;
							statusDisplay.textContent = "Uploading file...";

							// Reset audio controls
							stopAudio();
							playPauseButton.disabled = true;
							stopAudioButton.disabled = true;

							// Reset metrics
							resetMetrics();

							try {
								// Create a FormData object to send the file
								const formData = new FormData();
								formData.append("file", file);

								// Upload the file to the server
								const response = await fetch("/upload", {
									method: "POST",
									body: formData,
								});

								if (!response.ok) {
									const errorData = await response.json();
									throw new Error(errorData.error || "Unknown error");
								}

								// Get response data including task ID
								const data = await response.json();
								currentTaskId = data.task_id;

								// Enable stop button now that processing has started
								stopButton.disabled = false;

								// File uploaded successfully
								statusDisplay.textContent = "File uploaded, processing on server...";
								isProcessingRemote = true;

								// Also play locally for the user
								const fileURL = URL.createObjectURL(file);
								audio.src = fileURL;
								fileNameDisplay.textContent = `Playing: ${file.name}`;

								// Initialize Web Audio API for local visualization
								if (!audioContext) {
									initAudioContext();
								}
							} catch (error) {
								console.error("Error:", error);
								statusDisplay.textContent = `Error: ${error.message}`;
								fileNameDisplay.textContent = "Upload failed";
								stopButton.disabled = true;
								playPauseButton.disabled = true;
								stopAudioButton.disabled = true;
							}
						}

						// File upload handling for both top and bottom file inputs
						function handleFileUpload(event) {
							const file = event.target.files[0];
							if (!file) return;

							// Display the name of the file
							fileNameDisplay.textContent = `Processing: ${file.name}`;
							statusDisplay.textContent = "Uploading file...";

							// Reset audio controls
							stopAudio();
							playPauseButton.disabled = true;
							stopAudioButton.disabled = true;

							// Reset metrics
							resetMetrics();

							// Create a FormData object and upload
							uploadFile(file);
						}

						fileUpload.addEventListener("change", handleFileUpload);
						bottomFileUpload.addEventListener("change", handleFileUpload);

						// Common file upload function
						async function uploadFile(file) {
							try {
								// Create a FormData object to send the file
								const formData = new FormData();
								formData.append("file", file);

								// Upload the file to the server
								const response = await fetch("/upload", {
									method: "POST",
									body: formData,
								});

								if (!response.ok) {
									const errorData = await response.json();
									throw new Error(errorData.error || "Unknown error");
								}

								// Get response data including task ID
								const data = await response.json();
								currentTaskId = data.task_id;

								// Enable stop button now that processing has started
								stopButton.disabled = false;

								// File uploaded successfully
								statusDisplay.textContent = "File uploaded, processing on server...";
								isProcessingRemote = true;

								// Also play locally for the user
								const fileURL = URL.createObjectURL(file);
								audio.src = fileURL;
								fileNameDisplay.textContent = `Playing: ${file.name}`;

								// Initialize Web Audio API for local visualization
								if (!audioContext) {
									initAudioContext();
								}
							} catch (error) {
								console.error("Error:", error);
								statusDisplay.textContent = `Error: ${error.message}`;
								fileNameDisplay.textContent = "Upload failed";
								stopButton.disabled = true;
								playPauseButton.disabled = true;
								stopAudioButton.disabled = true;
							}
						}

						// Bottom drop area event listeners
						bottomDropArea.addEventListener("dragover", (event) => {
							event.preventDefault();
							bottomDropArea.style.backgroundColor = "#f0f0f0";
						});

						bottomDropArea.addEventListener("dragleave", () => {
							bottomDropArea.style.backgroundColor = "";
						});

						bottomDropArea.addEventListener("drop", (event) => {
							event.preventDefault();
							bottomDropArea.style.backgroundColor = "";

							const file = event.dataTransfer.files[0];
							if (!file) return;

							// Reset metrics
							resetMetrics();

							// Use the common upload function
							uploadFile(file);
						});

						function initAudioContext() {
							audioContext = new (window.AudioContext || window.webkitAudioContext)();
							const source = audioContext.createMediaElementSource(audio);
							analyser = audioContext.createAnalyser();

							// Set FFT size based on visualizer settings
							analyser.fftSize = visualizerSettings.resolution * 2;
							analyser.smoothingTimeConstant = visualizerSettings.smoothingFactor;
							const bufferLength = analyser.frequencyBinCount;
							dataArray = new Uint8Array(bufferLength);

							source.connect(analyser);
							analyser.connect(audioContext.destination);

							// Start the animation loop
							animationFrameId = requestAnimationFrame(animate);
						}

						function animate() {
							animationFrameId = requestAnimationFrame(animate);

							// Calculate frame rate and rendering time
							const now = performance.now();
							if (clientMetrics.lastFrameTime) {
								const frameTime = now - clientMetrics.lastFrameTime;
								const fps = 1000 / frameTime;
								clientMetrics.frameRates.push(fps);
								clientMetrics.renderTimes.push(frameTime);

								// Keep only last 60 samples for moving average
								if (clientMetrics.frameRates.length > 60) {
									clientMetrics.frameRates.shift();
									clientMetrics.renderTimes.shift();
								}
							}
							clientMetrics.lastFrameTime = now;

							renderVisualization();
							updateClientMetrics();
						}

						function renderVisualization() {
							// Don't render if visualizer elements aren't ready
							if (!ctx || !canvas) return;

							const width = canvas.width;
							const height = canvas.height;
							ctx.clearRect(0, 0, width, height);

							// Get frequency data from local analyser OR server data
							let frequencyData;
							if (analyser && !isProcessingRemote) {
								// Use local data if not processing remotely
								analyser.getByteFrequencyData(dataArray);
								frequencyData = Array.from(dataArray);
							} else if (serverChunks.length > 0) {
								// Use latest server data if available
								const latestChunk = getLatestServerChunk();
								if (latestChunk) {
									frequencyData = latestChunk;
								} else {
									// Fallback if no server data
									return;
								}
							} else {
								// No data available
								return;
							}

							// Calculate bar properties based on available width and data
							const totalBars = frequencyData.length;
							const barGap = Math.max(1, visualizerSettings.barWidth / 3);
							const barWidth =
								(Math.max(1, width / totalBars - barGap) * visualizerSettings.barWidth) /
								2;

							// Draw visualization bars
							let x = 0;
							for (let i = 0; i < totalBars; i++) {
								// Normalize bar height to canvas height
								let barHeight;
								if (
									frequencyData[i] instanceof Number ||
									typeof frequencyData[i] === "number"
								) {
									if (frequencyData[i] <= 1) {
										// Normalized data (0-1)
										barHeight = frequencyData[i] * height;
									} else {
										// Byte data (0-255)
										barHeight = (frequencyData[i] / 255) * height;
									}
								} else {
									continue; // Skip invalid data
								}

								// Apply color scheme
								const colorScheme = colorSchemes[visualizerSettings.colorScheme];
								if (colorScheme) {
									if (typeof colorScheme.gradient === "function") {
										// Color schemes that need to know about bar index
										if (colorScheme === colorSchemes.rainbow) {
											ctx.fillStyle = colorScheme.gradient(
												ctx,
												height,
												barHeight,
												i,
												totalBars
											);
										} else {
											ctx.fillStyle = colorScheme.gradient(ctx, height, barHeight);
										}
									} else {
										// Fallback to solid color
										if (typeof colorScheme.solid === "function") {
											ctx.fillStyle = colorScheme.solid(i, totalBars);
										} else {
											ctx.fillStyle = colorScheme.solid;
										}
									}
								} else {
									// Default fallback color
									ctx.fillStyle = "#4285f4";
								}

								ctx.fillRect(x, height - barHeight, barWidth, barHeight);
								x += barWidth + barGap;
							}
						}

						function getLatestServerChunk() {
							if (serverChunks.length === 0) return null;

							// Find the last non-null chunk
							for (let i = serverChunks.length - 1; i >= 0; i--) {
								if (serverChunks[i]) {
									return serverChunks[i];
								}
							}

							return null;
						}

						function updateClientMetrics() {
							// Update frame rate display
							if (clientMetrics.frameRates.length > 0) {
								const avgFps =
									clientMetrics.frameRates.reduce((sum, val) => sum + val, 0) /
									clientMetrics.frameRates.length;
								frameRateElement.textContent = `${Math.round(avgFps)} FPS`;
							}

							// Update render time display
							if (clientMetrics.renderTimes.length > 0) {
								const avgRenderTime =
									clientMetrics.renderTimes.reduce((sum, val) => sum + val, 0) /
									clientMetrics.renderTimes.length;
								renderTimeElement.textContent = `${avgRenderTime.toFixed(2)} ms`;
							}

							// Update client memory usage if available
							if (window.performance && window.performance.memory) {
								const memoryUsageMB = Math.round(
									window.performance.memory.usedJSHeapSize / (1024 * 1024)
								);
								clientMemoryElement.textContent = `${memoryUsageMB} MB`;
							}

							// Calculate smoothness (frame time consistency)
							if (clientMetrics.renderTimes.length > 5) {
								const stdDev = calculateStandardDeviation(clientMetrics.renderTimes);
								const mean =
									clientMetrics.renderTimes.reduce((sum, val) => sum + val, 0) /
									clientMetrics.renderTimes.length;
								// Lower stdDev relative to mean = more consistent frame times = smoother animation
								const smoothness = Math.max(0, 100 - (stdDev / mean) * 100);
								smoothnessElement.textContent = `${Math.round(smoothness)}%`;
							}
						}

						function updateMetricsDisplay() {
							// Update server metrics displays with more detail
							cpuUsageElement.textContent = `${Math.round(serverMetrics.cpuUsage)}%`;

							// Calculate CPU trend
							const cpuTrend = document.getElementById('cpu-trend');
							if (serverMetrics.lastCpuUsage) {
								const cpuDelta = serverMetrics.cpuUsage - serverMetrics.lastCpuUsage;
								if (cpuDelta > 2) {
									cpuTrend.className = 'metric-trend trend-up';
									cpuTrend.textContent = `+${cpuDelta.toFixed(1)}%`;
								} else if (cpuDelta < -2) {
									cpuTrend.className = 'metric-trend trend-down';
									cpuTrend.textContent = `${cpuDelta.toFixed(1)}%`;
								} else {
									cpuTrend.className = 'metric-trend trend-stable';
									cpuTrend.textContent = 'stable';
								}
							}
							serverMetrics.lastCpuUsage = serverMetrics.cpuUsage;

							// Memory usage with trend
							memoryUsageElement.textContent = `${Math.round(serverMetrics.memoryUsage)}%`;
							const memoryTrend = document.getElementById('memory-trend');
							if (serverMetrics.lastMemoryUsage) {
								const memDelta = serverMetrics.memoryUsage - serverMetrics.lastMemoryUsage;
								if (memDelta > 1) {
									memoryTrend.className = 'metric-trend trend-up';
									memoryTrend.textContent = `+${memDelta.toFixed(1)}%`;
								} else if (memDelta < -1) {
									memoryTrend.className = 'metric-trend trend-down';
									memoryTrend.textContent = `${memDelta.toFixed(1)}%`;
								} else {
									memoryTrend.className = 'metric-trend trend-stable';
									memoryTrend.textContent = 'stable';
								}
							}
							serverMetrics.lastMemoryUsage = serverMetrics.memoryUsage;

							// Processing time with detailed stats
							if (serverMetrics.processingTimes.length > 0) {
								const procTimes = serverMetrics.processingTimes;
								const avgProcessingTime = procTimes.reduce((sum, val) => sum + val, 0) / procTimes.length;
								const minProcessingTime = Math.min(...procTimes);
								const maxProcessingTime = Math.max(...procTimes);

								processingTimeElement.textContent = `${avgProcessingTime.toFixed(2)} ms`;
								document.getElementById('processing-time-detail').textContent =
									`Min: ${minProcessingTime.toFixed(1)}ms | Max: ${maxProcessingTime.toFixed(1)}ms`;
							}

							// Chunks processed with rate
							chunksProcessedElement.textContent = serverMetrics.chunksProcessed;

							// Calculate processing rate (chunks per second)
							const now = Date.now();
							if (serverMetrics.lastChunkTime) {
								const timeDiff = now - serverMetrics.lastChunkTime;
								if (timeDiff > 0 && serverMetrics.lastChunksProcessed) {
									const chunksDiff = serverMetrics.chunksProcessed - serverMetrics.lastChunksProcessed;
									const rate = (chunksDiff / timeDiff) * 1000; // chunks per second
									document.getElementById('processing-rate').textContent = `${rate.toFixed(1)} chunks/sec`;
								}
							}

							// Store current values for next calculation
							serverMetrics.lastChunkTime = now;
							serverMetrics.lastChunksProcessed = serverMetrics.chunksProcessed;

							// Network metrics
							// Calculate average, min, max latency
							if (clientMetrics.packetLatencies.length > 0) {
								const latencies = clientMetrics.packetLatencies;
								const avgLatency = latencies.reduce((sum, val) => sum + val, 0) / latencies.length;
								// Only use recent latencies to avoid old data affecting min/max
								const recentLatencies = latencies.slice(-20);
								const minLatency = Math.min(...recentLatencies);
								const maxLatency = Math.max(...recentLatencies);

								document.getElementById('network-latency').textContent = `${Math.round(avgLatency)} ms`;
								document.getElementById('latency-detail').textContent =
									`Min: ${Math.round(minLatency)}ms | Max: ${Math.round(maxLatency)}ms`;
							}

							// Data received with bandwidth calculation
							document.getElementById('data-received').textContent = `${Math.round(serverMetrics.totalDataReceived / 1024)} KB`;

							if (serverMetrics.lastDataTime) {
								const timeDiff = now - serverMetrics.lastDataTime
			;
								if (timeDiff > 0 && serverMetrics.lastTotalDataReceived) {
									const dataDiff = serverMetrics.totalDataReceived - serverMetrics.lastTotalDataReceived;
									const bandwidth = (dataDiff / timeDiff) * 1000 / 1024; // KB per second
									document.getElementById('bandwidth').textContent = `${bandwidth.toFixed(1)} KB/s`;
								}
							}
							serverMetrics.lastDataTime = now;
							serverMetrics.lastTotalDataReceived = serverMetrics.totalDataReceived;

							// Packet stats
							document.getElementById('packets-received').textContent = clientMetrics.packetsReceived;
							document.getElementById('packets-lost').textContent = clientMetrics.packetsLost;

							// Calculate packet loss rate
							const totalPackets = clientMetrics.packetsReceived + clientMetrics.packetsLost;
							if (totalPackets > 0) {
								const lossRate = (clientMetrics.packetsLost / totalPackets) * 100;
								document.getElementById('packet-loss-rate').textContent = `${lossRate.toFixed(1)}%`;
							}

							// Calculate packet rate
							if (serverMetrics.lastPacketTime) {
								const timeDiff = now - serverMetrics.lastPacketTime;
								if (timeDiff > 0 && serverMetrics.lastPacketsReceived) {
									const packetsDiff = clientMetrics.packetsReceived - serverMetrics.lastPacketsReceived;
									const rate = (packetsDiff / timeDiff) * 1000; // packets per second
									document.getElementById('packets-rate').textContent = `${rate.toFixed(1)}/sec`;
								}
							}
							serverMetrics.lastPacketTime = now;
							serverMetrics.lastPacketsReceived = clientMetrics.packetsReceived;
						}

						function resetMetrics() {
							// Reset server metrics
							serverMetrics = {
								cpuUsage: 0,
								memoryUsage: 0,
								processingTimes: [],
								chunksProcessed: 0,
								totalDataReceived: 0,
							};

							// Reset client metrics
							clientMetrics = {
								frameRates: [],
								renderTimes: [],
								lastFrameTime: 0,
								packetLatencies: [],
								packetsReceived: 0,
								packetsLost: 0,
								lostPacketIds: new Set(),
							};

							// Reset server chunks array
							serverChunks = [];

							// Update displays
							cpuUsageElement.textContent = "0%";
							memoryUsageElement.textContent = "0 MB";
							processingTimeElement.textContent = "0 ms";
							chunksProcessedElement.textContent = "0";
							frameRateElement.textContent = "0 FPS";
							renderTimeElement.textContent = "0 ms";
							clientMemoryElement.textContent = "0 MB";
							smoothnessElement.textContent = "100%";
							networkLatencyElement.textContent = "0 ms";
							dataReceivedElement.textContent = "0 KB";
							packetsReceivedElement.textContent = "0";
							packetsLostElement.textContent = "0";
						}

						// Helper function to calculate standard deviation
						function calculateStandardDeviation(array) {
							const n = array.length;
							if (n === 0) return 0;

							const mean = array.reduce((sum, val) => sum + val, 0) / n;
							const variance =
								array.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;
							return Math.sqrt(variance);
						}

						// Clean up when page is unloaded
						window.addEventListener("beforeunload", () => {
							if (updateTimeInterval) {
								clearInterval(updateTimeInterval);
							}
							if (animationFrameId) {
								cancelAnimationFrame(animationFrameId);
							}
						});

						// Initialize the visualization settings when page loads
						window.addEventListener("DOMContentLoaded", () => {
							// Initialize all displays with default values
							updateResolution();
							updateSmoothing();
							updateBarWidth();
							updateVolume();
							updateSpeed();
						});

						// Color picker functionality
						const colorPicker = document.getElementById("color-picker");
						const customColorBtn = document.getElementById("custom-color-btn");
						const bgColorPicker = document.getElementById("bg-color-picker");
						const bgColorDisplay = document.getElementById("bg-color-display");

						// Custom color button
						customColorBtn.addEventListener("click", () => {
							// Deselect all predefined color themes
							colorButtons.forEach(btn => btn.classList.remove("active"));

							// Apply the custom color
							applyCustomColor();

							// Show color picker
							colorPicker.click();
						});

						// Custom color picker change
						colorPicker.addEventListener("change", applyCustomColor);
						colorPicker.addEventListener("input", applyCustomColor);

						function applyCustomColor() {
							const selectedColor = colorPicker.value;
							// Create a custom color scheme on the fly
							colorSchemes.custom = {
								gradient: function(ctx, height, barHeight) {
									const gradient = ctx.createLinearGradient(0, height, 0, height - barHeight);
									gradient.addColorStop(0, selectedColor);
									// Create a lighter version for gradient effect
									gradient.addColorStop(1, lightenColor(selectedColor, 30));
									return gradient;
								},
								solid: selectedColor
							};

							// Apply the custom color scheme
							visualizerSettings.colorScheme = 'custom';
						}

						// Background color picker
						bgColorPicker.addEventListener("change", updateBackgroundColor);
						bgColorPicker.addEventListener("input", updateBackgroundColor);

						function updateBackgroundColor() {
							const selectedBgColor = bgColorPicker.value;
							canvas.style.backgroundColor = selectedBgColor;
							bgColorDisplay.textContent = selectedBgColor;
						}

						// Helper function to lighten a color
						function lightenColor(color, percent) {
							// Convert hex to RGB
							let r = parseInt(color.substring(1,3), 16);
							let g = parseInt(color.substring(3,5), 16);
							let b = parseInt(color.substring(5,7), 16);

							// Lighten
							r = Math.min(255, r + Math.floor(percent/100 * (255 - r)));
							g = Math.min(255, g + Math.floor(percent/100 * (255 - g)));
							b = Math.min(255, b + Math.floor(percent/100 * (255 - b)));

							// Convert back to hex
							return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
						}

						// Visualization style selector
						const vizStyleSelect = document.getElementById("viz-style");
						vizStyleSelect.addEventListener("change", () => {
							visualizerSettings.vizStyle = vizStyleSelect.value;
						});

						// Parameter impact monitor
						const runImpactTestBtn = document.getElementById("run-impact-test");
						const impactTestResult = document.getElementById("impact-test-result");
						const resolutionImpact = document.getElementById("resolution-impact");
						const smoothingImpact = document.getElementById("smoothing-impact");
						const chunkImpact = document.getElementById("chunk-impact");
						const networkImpact = document.getElementById("network-impact");
						const vizStyleImpact = document.getElementById("viz-style-impact");

						runImpactTestBtn.addEventListener("click", runImpactTest);

						function runImpactTest() {
							impactTestResult.textContent = "Running parameter impact test with real metrics...";
							runImpactTestBtn.disabled = true;

							// Use collected real metrics data
							const realMetrics = collectCurrentMetrics();

							// Only proceed if we have actual data
							if (realMetrics.processingTime > 0 || realMetrics.latency > 0 || realMetrics.fps > 0) {
								impactTestResult.textContent = "Using real performance data from current session...";

								// Update all impact bars with real data
								updateAllImpactBars(realMetrics);
							} else {
								// Not enough real data, inform the user
								impactTestResult.textContent = "No sufficient performance data yet. Please process some audio first.";
								setTimeout(() => {
									runImpactTestBtn.disabled = false;
								}, 1500);
							}
						}

						function collectCurrentMetrics() {
							// Get the real metrics from the current session
							return {
								cpu: serverMetrics.cpuUsage || 0,
								memory: serverMetrics.memoryUsage || 0,
								processingTime: serverMetrics.processingTimes.length > 0 ?
									serverMetrics.processingTimes.reduce((sum, val) => sum + val, 0) /
									serverMetrics.processingTimes.length : 0,
								fps: clientMetrics.frameRates.length > 0 ?
									clientMetrics.frameRates.reduce((sum, val) => sum + val, 0) /
									clientMetrics.frameRates.length : 0,
								latency: clientMetrics.packetLatencies.length > 0 ?
									clientMetrics.packetLatencies.reduce((sum, val) => sum + val, 0) /
									clientMetrics.packetLatencies.length : 0,
								packetsLost: clientMetrics.packetsLost,
								packetsReceived: clientMetrics.packetsReceived
							};
						}

						function updateAllImpactBars(metrics) {
							// Calculate and update all impact bars based on real metrics in parallel
							setTimeout(() => updateResolutionImpactReal(metrics), 100);
							setTimeout(() => updateSmoothingImpactReal(metrics), 300);
							setTimeout(() => updateChunkSizeImpactReal(metrics), 500);
							setTimeout(() => updateNetworkImpactReal(metrics), 700);
							setTimeout(() => updateVizStyleImpactReal(metrics), 900);

							// Finish the test after all updates
							setTimeout(() => {
								// Find the highest impact parameter
								const impacts = [
									{ name: "Resolution", element: resolutionImpact },
									{ name: "Smoothing", element: smoothingImpact },
									{ name: "Chunk Size", element: chunkImpact },
									{ name: "Network Delay", element: networkImpact },
									{ name: "Visualization Style", element: vizStyleImpact }
								];

								// Get the width values from the style attribute
								const impactValues = impacts.map(item => {
									return {
										name: item.name,
										value: parseFloat(item.element.style.width) || 0
									};
								});

								// Sort by impact value descending
								impactValues.sort((a, b) => b.value - a.value);

								// Show top 2 highest impact parameters
								const highest = impactValues[0];
								const second = impactValues[1];
								impactTestResult.textContent = `Analysis complete! ${highest.name} (${Math.round(highest.value)}%) and ${second.name} (${Math.round(second.value)}%) have the most significant impact on system performance.`;
								runImpactTestBtn.disabled = false;

								// Update the impact values every 5 seconds to keep them current
								startRealTimeImpactUpdates(metrics);
							}, 1200);
						}

						// Variables for real-time update tracking
						let realTimeUpdateInterval = null;

						function startRealTimeImpactUpdates(initialMetrics) {
							// Clear any existing interval
							if (realTimeUpdateInterval) {
								clearInterval(realTimeUpdateInterval);
							}

							// Set up real-time updates every 5 seconds
							realTimeUpdateInterval = setInterval(() => {
								// Only update if we have active processing
								if (isProcessingRemote || (clientMetrics.frameRates.length > 0)) {
									const currentMetrics = collectCurrentMetrics();
									updateAllImpactBarsQuiet(currentMetrics);
								}
							}, 5000);
						}

						function updateAllImpactBarsQuiet(metrics) {
							// Update all bars without animation or UI notifications
							updateResolutionImpactReal(metrics);
							updateSmoothingImpactReal(metrics);
							updateChunkSizeImpactReal(metrics);
							updateNetworkImpactReal(metrics);
							updateVizStyleImpactReal(metrics);
						}

						function updateResolutionImpactReal(metrics) {
							let score = 0;

							// Calculate based on real metrics
							if (metrics.fps > 0) {
								// Higher resolution correlates with lower FPS - use inverse relationship
								const fpsImpact = Math.max(0, 60 - metrics.fps) / 60 * 50; // Up to 50% from FPS

								// Resolution setting direct impact
								const resolutionImpact = (visualizerSettings.resolution / 512) * 50; // Up to 50% from resolution setting

								// Combined impact
								score = Math.min(100, fpsImpact + resolutionImpact);
							} else if (metrics.processingTime > 0) {
								// If we have processing time but no FPS, estimate based on resolution and processing time
								score = Math.min(100, (visualizerSettings.resolution / 256) * 40 +
									Math.min(40, (metrics.processingTime / 10) * 20));
							}

							// Make sure we have a minimum score
							score = Math.max(15, score);

							updateImpactBar(resolutionImpact, score);
						}

						function updateSmoothingImpactReal(metrics) {
							let score = 0;

							// Smoothing mainly affects rendering performance
							if (metrics.processingTime > 0) {
								// Higher smoothing means more calculation overhead
								const smoothingBase = visualizerSettings.smoothingFactor * 25; // Up to 25% from smoothing setting

								// Additional impact from rendering time
								const renderImpact = metrics.fps > 0 ?
									Math.max(0, (1 - (metrics.fps / 60))) * 15 : 0; // Up to 15% from FPS

								score = Math.min(100, smoothingBase + renderImpact);
							} else {
								// Fallback if no metrics
								score = Math.min(40, 5 + visualizerSettings.smoothingFactor * 30);
							}

							// Smoothing typically has low impact
							score = Math.min(40, Math.max(5, score));

							updateImpactBar(smoothingImpact, score);
						}

						function updateChunkSizeImpactReal(metrics) {
							let score = 0;

							// Chunk size has major impact on server processing time
							if (metrics.processingTime > 0) {
								// Base impact from current processing time
								const processingImpact = Math.min(50, (metrics.processingTime / 20) * 50);

								// Additional impact from CPU usage
								const cpuImpact = Math.min(30, (metrics.cpu / 100) * 30);

								// Chunk size setting impact
								const chunkSizeMap = {
									"small": 20,
									"medium": 40,
									"large": 60
								};
								const chunkSizeImpact = chunkSizeMap[visualizerSettings.chunkSize] || 40;

								// Combined score with limits
								score = Math.min(95, processingImpact + cpuImpact + (chunkSizeImpact / 3));
							} else {
								// Fallback to chunk size setting only
								const chunkSizeMap = {
									"small": 40,
									"medium": 65,
									"large": 80
								};
								score = chunkSizeMap[visualizerSettings.chunkSize] || 65;
							}

							// Ensure minimum impact
							score = Math.max(30, score);

							updateImpactBar(chunkImpact, score);
						}

						function updateNetworkImpactReal(metrics) {
							let score = 0;

							// Network impact calculation - highest priority if network issues exist
							if (metrics.latency > 0 || visualizerSettings.networkDelay > 0 || visualizerSettings.packetLoss > 0) {
								// Impact from real network latency
								const latencyImpact = Math.min(40, (metrics.latency / 200) * 40); // Up to 40% from latency

								// Impact from packet loss
								let packetLossImpact = 0;
								if (metrics.packetsLost > 0 && (metrics.packetsLost + metrics.packetsReceived) > 0) {
									const lossRate = metrics.packetsLost / (metrics.packetsLost + metrics.packetsReceived);
									packetLossImpact = Math.min(50, lossRate * 100);
								}

								// Impact from simulated network conditions
								const simulatedDelayImpact = Math.min(60, (visualizerSettings.networkDelay / 1000) * 60);
								const simulatedLossImpact = Math.min(70, visualizerSettings.packetLoss * 1.4);

								// Take the highest impact factor and add some from others
								const highestImpact = Math.max(latencyImpact, packetLossImpact,
									simulatedDelayImpact, simulatedLossImpact);

								// Add some from other factors but ensure we don't exceed 100%
								score = Math.min(100, highestImpact +
									(latencyImpact + packetLossImpact + simulatedDelayImpact + simulatedLossImpact - highestImpact) * 0.3);
							} else {
								// Fallback with low baseline impact
								score = 20;
							}

							// Ensure minimum impact
							score = Math.max(20, score);

							updateImpactBar(networkImpact, score);
						}

						function updateVizStyleImpactReal(metrics) {
							let score = 0;

							// Visualization style impact calculation
							if (metrics.fps > 0 || metrics.processingTime > 0) {
								// Different styles have different rendering complexity
								const styleFactors = {
									"bars": 30,
									"wave": 45, // More complex to render
									"circle": 60  // Most complex to render
								};

								const styleBase = styleFactors[visualizerSettings.vizStyle] || 40;

								// Additional impact from actual rendering performance
								const renderImpact = metrics.fps > 0 ?
									Math.max(0, (1 - (metrics.fps / 60))) * 30 : 0;

								score = Math.min(90, styleBase + renderImpact);
							} else {
								// Fallback based on style complexity only
								const styleFactors = {
									"bars": 35,
									"wave": 50,
									"circle": 65
								};
								score = styleFactors[visualizerSettings.vizStyle] || 40;
							}

							// Ensure reasonable range
							score = Math.min(90, Math.max(20, score));

							updateImpactBar(vizStyleImpact, score);
						}
		</script>
	</body>
</html>
