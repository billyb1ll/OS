<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Music Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0; /* Lighter background */
            color: #333;
            padding-top: 20px;
        }
        #player-container {
            width: 800px; /* Match canvas width */
            background-color: #fff; /* White background for the player area */
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden; /* Keep elements contained */
        }
        #drop-area, #bottom-drop-area {
            border: 2px dashed #ccc;
            padding: 30px;
            width: calc(100% - 64px); /* Adjust width considering padding */
            text-align: center;
            margin: 20px auto; /* Center the drop area */
            color: #666;
            background-color: #fafafa;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #drop-area {
            padding: 50px 30px;
        }
        .file-upload-btn {
            margin-top: 15px;
            padding: 8px 16px;
            background-color: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .file-upload-btn:hover {
            background-color: #3367d6;
        }
        .file-upload-btn::before {
            content: "üìÅ";
        }
        .file-input {
            display: none; /* Hide the native file input */
        }
        
        /* Test songs section */
        #test-songs-container {
            width: calc(100% - 64px);
            max-width: 800px;
            margin: 10px auto 20px;
            text-align: center;
            padding: 10px 15px 15px;
            background-color: #e8f0fe;
            border-radius: 8px;
            border: 1px solid #c9d6eb;
        }
        #test-songs-container h3 {
            margin: 5px 0 10px;
            font-size: 16px;
            color: #4285f4;
        }
        #test-songs-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin: 0;
            padding: 0;
        }
        .test-song-btn {
            background-color: #4285f4;
            color: white;
            border: none;
            border-radius: 30px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 13px;
            margin: 5px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
            transition: all 0.2s ease;
        }
        .test-song-btn:hover {
            background-color: #3367d6;
            transform: scale(1.05);
        }
        .test-song-btn:before {
            content: "üéµ";
            margin-right: 5px;
        }
        #test-songs-loading {
            color: #666;
            font-style: italic;
            margin: 10px 0;
        }
        
        #canvas {
            display: block; /* Remove extra space below canvas */
            background-color: #000; /* Black background for visualizer */
            width: 100%; /* Make canvas fill container width */
        }
        audio {
            display: none; /* Hide the audio element */
        }
        #status {
            margin-top: 10px;
            font-style: italic;
            color: #666;
            text-align: center;
            width: 100%;
        }
        #controls-bar {
            background-color: #282828; /* Dark background for controls */
            padding: 10px 15px;
            color: #fff;
        }
        #seek-bar-container {
            padding: 5px 0;
        }
        #seek-bar {
            width: 100%;
            cursor: pointer;
            height: 5px; /* Thinner seek bar */
            appearance: none; /* Override default look */
            background: #555; /* Track background */
            border-radius: 3px;
            outline: none;
        }
        /* Style seek bar thumb */
        #seek-bar::-webkit-slider-thumb {
            appearance: none;
            width: 15px;
            height: 15px;
            background: #e50914; /* YouTube-like red */
            border-radius: 50%;
            cursor: pointer;
        }
        #seek-bar::-moz-range-thumb {
            width: 15px;
            height: 15px;
            background: #e50914;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        #main-controls {
            display: flex;
            align-items: center;
            gap: 15px; /* Space between control groups */
            flex-wrap: wrap;
            justify-content: space-between; /* Distribute space */
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px; /* Smaller gap within groups */
        }
        .left-controls, .right-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        button {
            padding: 8px 12px; /* Slightly smaller buttons */
            cursor: pointer;
            background-color: transparent; /* Transparent background */
            border: none; /* No border */
            color: #fff; /* White text/icons */
            font-size: 18px; /* Larger font size for icon-like feel */
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }
        button:hover {
            background-color: rgba(255, 255, 255, 0.2); /* Subtle hover effect */
        }
        button:disabled {
            color: #888; /* Dim disabled buttons */
            background-color: transparent;
            cursor: not-allowed;
        }
        /* Specific button styles (optional, could use icons) */
        #play-pause-button::before { content: '‚ñ∂'; margin-right: 5px; } /* Simple play icon */
        #play-pause-button.playing::before { content: '‚ùö‚ùö'; margin-right: 5px; } /* Simple pause icon */
        #stop-audio-button::before { content: '‚ñ†'; margin-right: 5px; } /* Simple stop icon */

        label {
            font-size: 13px;
            margin-right: 0;
            color: #ccc;
        }
        input[type="range"] {
            width: 80px; /* Smaller range inputs */
            height: 4px;
            cursor: pointer;
            appearance: none;
            background: #555;
            border-radius: 2px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff; /* White thumb */
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        .value-display {
            min-width: 35px;
            text-align: right;
            font-size: 13px;
            color: #ccc;
        }
        .time-display {
            font-family: monospace;
            font-size: 14px;
            color: #fff;
        }
        #file-name {
            text-align: center;
            padding: 10px;
            font-size: 16px;
            color: #333;
            background-color: #eee; /* Light background for file name */
            border-bottom: 1px solid #ddd;
        }
        /* Hide stop processing button for now */
        #stop-button { display: none; }

        #bottom-drop-area {
            width: 80%; /* Adjust width as needed */
            max-width: 800px; /* Match player width */
            margin: 30px auto; /* Add space above and center */
        }

        /* Responsive Design */
        @media (max-width: 850px) { /* Adjust breakpoint as needed */
            #player-container {
                width: 95%; /* Use more width on smaller screens */
            }
            #main-controls {
                flex-direction: column; /* Stack controls vertically */
                align-items: flex-start; /* Align items to the start */
                gap: 10px;
            }
            .left-controls, .right-controls {
                width: 100%; /* Make control groups take full width */
                justify-content: space-between; /* Space out items within groups */
            }
            .right-controls {
                flex-direction: column; /* Stack right controls */
                align-items: flex-start;
                gap: 10px;
            }
            .control-group {
                width: 100%;
                justify-content: space-between;
            }
            input[type="range"] {
                width: 150px; /* Give sliders more space */
            }
            #bottom-drop-area {
                width: 90%;
            }
            .file-upload-btn {
                margin-top: 15px;
                padding: 10px 20px;
                font-size: 16px;
            }
        }

        @media (max-width: 480px) { /* Further adjustments for very small screens */
            h1 {
                font-size: 1.5em;
            }
            #player-container {
                width: 100%;
                border-radius: 0;
                box-shadow: none;
            }
            #controls-bar {
                padding: 10px;
            }
            .left-controls {
                 flex-direction: column; /* Stack play/stop/time */
                 align-items: flex-start;
                 gap: 10px;
            }
            .time-display {
                align-self: flex-start; /* Align time to the start */
            }
            button {
                padding: 10px 15px; /* Slightly larger touch targets */
            }
            label {
                font-size: 12px;
            }
            .value-display {
                font-size: 12px;
            }
            #bottom-drop-area {
                width: 95%;
                padding: 20px;
            }
            /* Make upload button more prominent on mobile */
            .file-upload-btn {
                width: 80%;
                padding: 12px 10px;
                font-size: 16px;
                margin-top: 20px;
            }
        }

        footer {
            margin-top: 40px; /* Add space above the footer */
            padding: 15px;
            text-align: center;
            font-size: 12px;
            color: #888;
            width: 100%;
        }
    </style>
</head>
<body>
    <h1>Music Visualizer</h1>
    <h5>Recomended: Use Chrome or Firefox</h5>

    <div id="drop-area">
        <p>Drag and drop an MP3 file here</p>
        <label class="file-upload-btn">
            <input type="file" class="file-input" id="file-upload" accept="audio/*">
            Upload File
        </label>
    </div>


    <div id="test-songs-container">
        <h3>Available Test Songs</h3>
        <div id="test-songs-list">
            <!-- Test song buttons will be dynamically added here -->
        </div>
        <div id="test-songs-loading">Loading test songs...</div>
    </div>

    <div id="player-container">
        <h2 id="file-name">No file playing</h2> <!-- File name heading -->
        <canvas id="canvas" width="800" height="300"></canvas> <!-- Adjusted height -->
        <div id="controls-bar">
            <div id="seek-bar-container">
                <input type="range" id="seek-bar" min="0" max="100" step="0.1" value="0">
            </div>
            <div id="main-controls">
                <div class="left-controls">
                    <button id="play-pause-button" disabled>Play</button>
                    <button id="stop-audio-button" disabled>Stop</button>
                    <span class="time-display" id="time-display">00:00 / 00:00</span>
                </div>
                <div class="right-controls">
                    <div class="control-group">
                        <label for="volume-control">Volume:</label> <!-- Consider replacing with an icon -->
                        <input type="range" id="volume-control" min="0" max="1" step="0.01" value="1">
                        <span class="value-display" id="volume-display">100%</span>
                    </div>
                    <div class="control-group">
                        <label for="speed-control">Speed:</label>
                        <input type="range" id="speed-control" min="0.5" max="2" step="0.1" value="1">
                        <span class="value-display" id="speed-display">1.0x</span>
                    </div>
                    <!-- Stop processing button is hidden via CSS -->
                    <button id="stop-button" disabled>Stop Processing</button>
                </div>
            </div>
        </div>
    </div>

    <div id="status">Ready</div>
    <audio id="audio"></audio> 

    <!-- Bottom drop area for uploading additional songs -->
    <div id="bottom-drop-area">
        <p>Upload more music</p>
        <label class="file-upload-btn">
            <input type="file" class="file-input" id="bottom-file-upload" accept="audio/*">
            Upload File
        </label>
    </div>

    <footer>
        Powered by <a href="https://github.com/billyb1ll/OS" label="github">Billy</a>@Ratatatamoth group - 2025
    </footer>

    <script>
        const dropArea = document.getElementById('drop-area');
        const bottomDropArea = document.getElementById('bottom-drop-area');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const audio = document.getElementById('audio');
        const fileNameDisplay = document.getElementById('file-name');
        const statusDisplay = document.getElementById('status');
        const stopButton = document.getElementById('stop-button');
        const playPauseButton = document.getElementById('play-pause-button');
        const stopAudioButton = document.getElementById('stop-audio-button');
        const volumeControl = document.getElementById('volume-control');
        const volumeDisplay = document.getElementById('volume-display');
        const speedControl = document.getElementById('speed-control');
        const speedDisplay = document.getElementById('speed-display');
        const timeDisplay = document.getElementById('time-display');
        const seekBar = document.getElementById('seek-bar');
        const fileUpload = document.getElementById('file-upload');
        const bottomFileUpload = document.getElementById('bottom-file-upload');
        const testSongsContainer = document.getElementById('test-songs-container');
        const testSongsList = document.getElementById('test-songs-list');
        const testSongsLoading = document.getElementById('test-songs-loading');
        
        // Initialize socket.io connection
        const socket = io();
        
        let audioContext, analyser, dataArray;
        let isProcessingRemote = false;
        let currentTaskId = null;
        let updateTimeInterval = null;

        // Audio playback controls
        playPauseButton.addEventListener('click', togglePlayPause);
        stopAudioButton.addEventListener('click', stopAudio);
        volumeControl.addEventListener('input', updateVolume);
        speedControl.addEventListener('input', updateSpeed);

        // Load test songs dynamically
        async function loadTestSongs() {
            try {
                const response = await fetch('/test-songs');
                const songs = await response.json();

                if (songs.length === 0) {
                    testSongsLoading.textContent = 'No test songs available';
                    return;
                }

                testSongsLoading.style.display = 'none';

                songs.forEach(song => {
                    const button = document.createElement('button');
                    button.className = 'test-song-btn';
                    button.textContent = song.name;
                    button.addEventListener('click', () => {
                        // Reset audio if already playing
                        stopAudio();
                        
                        // Update UI
                        fileNameDisplay.textContent = `Playing: ${song.name}`;
                        statusDisplay.textContent = 'Loading test song...';
                        
                        // Set audio source
                        audio.src = song.url;
                        
                        // Enable controls
                        playPauseButton.disabled = false;
                        stopAudioButton.disabled = false;
                        
                        // Initialize audio context before playing
                        // This is the key fix - must be done AFTER setting audio.src but BEFORE play()
                        if (!audioContext) {
                            initAudioContext();
                        } else {
                            // If context already exists but was disconnected, reconnect it
                            try {
                                if (audioContext.state === 'suspended') {
                                    audioContext.resume();
                                }
                            } catch (e) {
                                console.log('Audio context resume error:', e);
                                // If there's an error with existing context, create a new one
                                initAudioContext();
                            }
                        }
                        
                        // Wait a bit to ensure resources are loaded, then play
                        setTimeout(() => {
                            audio.play()
                                .then(() => {
                                    statusDisplay.textContent = 'Playing test song';
                                })
                                .catch(err => {
                                    console.error('Error playing audio:', err);
                                    statusDisplay.textContent = `Error: ${err.message}`;
                                });
                        }, 100);
                    });
                    testSongsList.appendChild(button);
                });
            } catch (error) {
                console.error('Error loading test songs:', error);
                testSongsLoading.textContent = `Error: ${error.message}`;
            }
        }

        loadTestSongs();

        // Update seek bar as audio plays
        audio.addEventListener('timeupdate', () => {
            if (!audio.duration) return;
            seekBar.value = (audio.currentTime / audio.duration) * 100;
        });

        // Seek to position when user interacts with seek bar
        seekBar.addEventListener('input', () => {
            if (!audio.duration) return;
            audio.currentTime = (seekBar.value / 100) * audio.duration;
        });
        
        function togglePlayPause() {
            if (audio.paused) {
                audio.play();
                playPauseButton.textContent = 'Pause';
                playPauseButton.classList.add('playing');
            } else {
                audio.pause();
                playPauseButton.textContent = 'Play';
                playPauseButton.classList.remove('playing');
            }
        }
        
        function stopAudio() {
            audio.pause();
            audio.currentTime = 0;
            playPauseButton.textContent = 'Play';
            playPauseButton.classList.remove('playing');
            
            // Reset seek bar position
            seekBar.value = 0;
        }
        
        function updateVolume() {
            audio.volume = volumeControl.value;
            volumeDisplay.textContent = `${Math.round(volumeControl.value * 100)}%`;
        }
        
        function updateSpeed() {
            audio.playbackRate = speedControl.value;
            speedDisplay.textContent = `${speedControl.value}x`;
        }
        
        function updateTimeDisplay() {
            if (!audio.duration) return;
            
            const currentMinutes = Math.floor(audio.currentTime / 60);
            const currentSeconds = Math.floor(audio.currentTime % 60);
            const totalMinutes = Math.floor(audio.duration / 60);
            const totalSeconds = Math.floor(audio.duration % 60);
            
            timeDisplay.textContent = `${currentMinutes.toString().padStart(2, '0')}:${currentSeconds.toString().padStart(2, '0')} / ${totalMinutes.toString().padStart(2, '0')}:${totalSeconds.toString().padStart(2, '0')}`;
        }
        
        // Set up audio events
        audio.addEventListener('play', () => {
            playPauseButton.textContent = 'Pause';
            playPauseButton.classList.add('playing');
        });
        
        audio.addEventListener('pause', () => {
            playPauseButton.textContent = 'Play';
            playPauseButton.classList.remove('playing');
        });
        
        audio.addEventListener('ended', () => {
            playPauseButton.textContent = 'Play';
            playPauseButton.classList.remove('playing');
            // Reset seek bar visually
            if (seekBar) { // Check if seekBar exists
                seekBar.value = 0;
            }
        });
        
        audio.addEventListener('loadedmetadata', () => {
            playPauseButton.disabled = false;
            stopAudioButton.disabled = false;
            updateTimeDisplay();
            
            // Set up interval for updating time display
            if (updateTimeInterval) clearInterval(updateTimeInterval);
            updateTimeInterval = setInterval(updateTimeDisplay, 1000);
        });

        // Socket connection events
        socket.on('connect', () => {
            console.log('Connected to server');
            statusDisplay.textContent = 'Connected to server';
        });
        
        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            statusDisplay.textContent = 'Disconnected from server';
            stopButton.disabled = true;
        });
        
        socket.on('audio_chunk', (chunkData) => {
            console.log('Received audio chunk');
            // Process chunk data for visualization
            // You could update a visualization directly from server data here
        });
        
        socket.on('processing_complete', () => {
            console.log('Audio processing complete');
            statusDisplay.textContent = 'Audio processing complete';
            isProcessingRemote = false;
            stopButton.disabled = true;
        });
        
        socket.on('processing_stopped', () => {
            console.log('Audio processing stopped');
            statusDisplay.textContent = 'Processing stopped by user';
            isProcessingRemote = false;
            stopButton.disabled = true;
        });

        // Stop button event listener
        stopButton.addEventListener('click', async () => {
            if (!isProcessingRemote || !currentTaskId) return;
            
            try {
                statusDisplay.textContent = 'Stopping processing...';
                
                const response = await fetch('/stop-processing', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ task_id: currentTaskId })
                });
                
                const result = await response.json();
                
                if (!response.ok) {
                    throw new Error(result.error || 'Failed to stop processing');
                }
                
                console.log('Stop request sent successfully');
                // Wait for the server to confirm via socket
                
            } catch (error) {
                console.error('Error stopping processing:', error);
                statusDisplay.textContent = `Error: ${error.message}`;
            }
        });

        // Drag and drop event listeners for TOP area
        dropArea.addEventListener('dragover', (event) => {
            event.preventDefault();
            dropArea.style.backgroundColor = '#f0f0f0';
        });

        dropArea.addEventListener('dragleave', () => {
            dropArea.style.backgroundColor = '';
        });

        dropArea.addEventListener('drop', handleDrop);

        async function handleDrop(event) {
            event.preventDefault();
            // Reset background for BOTH drop areas
            dropArea.style.backgroundColor = '';

            // Hide the TOP drop area if it's still visible
            dropArea.style.display = 'none';

            const file = event.dataTransfer.files[0];
            if (!file) return;
            
            // Display the name of the file
            fileNameDisplay.textContent = `Processing: ${file.name}`;
            statusDisplay.textContent = 'Uploading file...';
            
            // Reset audio controls
            stopAudio();
            playPauseButton.disabled = true;
            stopAudioButton.disabled = true;
            
            try {
                // Create a FormData object to send the file
                const formData = new FormData();
                formData.append('file', file);
                
                // Upload the file to the server
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Unknown error');
                }
                
                // Get response data including task ID
                const data = await response.json();
                currentTaskId = data.task_id;
                
                // Enable stop button now that processing has started
                stopButton.disabled = false;
                
                // File uploaded successfully
                statusDisplay.textContent = 'File uploaded, processing on server...';
                isProcessingRemote = true;
                
                // Also play locally for the user
                const fileURL = URL.createObjectURL(file);
                audio.src = fileURL;
                fileNameDisplay.textContent = `Playing: ${file.name}`;
                
                // Initialize Web Audio API for local visualization
                if (!audioContext) {
                    initAudioContext();
                }
                
            } catch (error) {
                console.error('Error:', error);
                statusDisplay.textContent = `Error: ${error.message}`;
                fileNameDisplay.textContent = 'Upload failed';
                stopButton.disabled = true;
                playPauseButton.disabled = true;
                stopAudioButton.disabled = true;
            }
        }

        fileUpload.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            // Display the name of the file
            fileNameDisplay.textContent = `Processing: ${file.name}`;
            statusDisplay.textContent = 'Uploading file...';

            // Reset audio controls
            stopAudio();
            playPauseButton.disabled = true;
            stopAudioButton.disabled = true;

            try {
                // Create a FormData object to send the file
                const formData = new FormData();
                formData.append('file', file);

                // Upload the file to the server
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Unknown error');
                }

                // Get response data including task ID
                const data = await response.json();
                currentTaskId = data.task_id;

                // Enable stop button now that processing has started
                stopButton.disabled = false;

                // File uploaded successfully
                statusDisplay.textContent = 'File uploaded, processing on server...';
                isProcessingRemote = true;

                // Also play locally for the user
                const fileURL = URL.createObjectURL(file);
                audio.src = fileURL;
                fileNameDisplay.textContent = `Playing: ${file.name}`;

                // Initialize Web Audio API for local visualization
                if (!audioContext) {
                    initAudioContext();
                }

            } catch (error) {
                console.error('Error:', error);
                statusDisplay.textContent = `Error: ${error.message}`;
                fileNameDisplay.textContent = 'Upload failed';
                stopButton.disabled = true;
                playPauseButton.disabled = true;
                stopAudioButton.disabled = true;

                logger.error(`File upload error: ${error.message}`);
            }
        });

        bottomFileUpload.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            // Display the name of the file
            fileNameDisplay.textContent = `Processing: ${file.name}`;
            statusDisplay.textContent = 'Uploading file...';

            // Reset audio controls
            stopAudio();
            playPauseButton.disabled = true;
            stopAudioButton.disabled = true;

            try {
                // Create a FormData object to send the file
                const formData = new FormData();
                formData.append('file', file);

                // Upload the file to the server
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Unknown error');
                }

                // Get response data including task ID
                const data = await response.json();
                currentTaskId = data.task_id;

                // Enable stop button now that processing has started
                stopButton.disabled = false;

                // File uploaded successfully
                statusDisplay.textContent = 'File uploaded, processing on server...';
                isProcessingRemote = true;

                // Also play locally for the user
                const fileURL = URL.createObjectURL(file);
                audio.src = fileURL;
                fileNameDisplay.textContent = `Playing: ${file.name}`;

                // Initialize Web Audio API for local visualization
                if (!audioContext) {
                    initAudioContext();
                }

            } catch (error) {
                console.error('Error:', error);
                statusDisplay.textContent = `Error: ${error.message}`;
                fileNameDisplay.textContent = 'Upload failed';
                stopButton.disabled = true;
                playPauseButton.disabled = true;
                stopAudioButton.disabled = true;

                logger.error(`File upload error: ${error.message}`);
            }
        });

        bottomDropArea.addEventListener('dragover', (event) => {
            event.preventDefault();
            bottomDropArea.style.backgroundColor = '#f0f0f0';
        });

        bottomDropArea.addEventListener('dragleave', () => {
            bottomDropArea.style.backgroundColor = '';
        });

        bottomDropArea.addEventListener('drop', async (event) => {
            event.preventDefault();
            bottomDropArea.style.backgroundColor = '';

            const file = event.dataTransfer.files[0];
            if (!file) return;

            // Display the name of the file
            fileNameDisplay.textContent = `Processing: ${file.name}`;
            statusDisplay.textContent = 'Uploading file...';

            // Reset audio controls
            stopAudio();
            playPauseButton.disabled = true;
            stopAudioButton.disabled = true;

            try {
                // Create a FormData object to send the file
                const formData = new FormData();
                formData.append('file', file);

                // Upload the file to the server
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Unknown error');
                }

                // Get response data including task ID
                const data = await response.json();
                currentTaskId = data.task_id;

                // Enable stop button now that processing has started
                stopButton.disabled = false;

                // File uploaded successfully
                statusDisplay.textContent = 'File uploaded, processing on server...';
                isProcessingRemote = true;

                // Also play locally for the user
                const fileURL = URL.createObjectURL(file);
                audio.src = fileURL;
                fileNameDisplay.textContent = `Playing: ${file.name}`;

                // Initialize Web Audio API for local visualization
                if (!audioContext) {
                    initAudioContext();
                }

            } catch (error) {
                console.error('Error:', error);
                statusDisplay.textContent = `Error: ${error.message}`;
                fileNameDisplay.textContent = 'Upload failed';
                stopButton.disabled = true;
                playPauseButton.disabled = true;
                stopAudioButton.disabled = true;

                logger.error(`File upload error: ${error.message}`);
            }
        });

        function initAudioContext() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaElementSource(audio);
            analyser = audioContext.createAnalyser();

            analyser.fftSize = 256; // Size of FFT window for frequency resolution
            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);

            source.connect(analyser);
            analyser.connect(audioContext.destination);

            // Start the animation loop
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!analyser) return;

            // Get frequency data from the analyser
            analyser.getByteFrequencyData(dataArray);

            // Use canvas dimensions
            const width = canvas.width;
            const height = canvas.height;
            ctx.clearRect(0, 0, width, height);

            const barWidth = (width / dataArray.length) * 1.5; // Adjusted bar width calculation
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height; // Scale bar height to canvas height
                // Gradient or solid color for bars
                const gradient = ctx.createLinearGradient(0, height, 0, height - barHeight);
                gradient.addColorStop(0, '#e50914'); // Red at the bottom
                gradient.addColorStop(1, '#f8a1a6'); // Lighter red at the top
                ctx.fillStyle = gradient;
                // ctx.fillStyle = `#e50914`; // Solid red alternative
                ctx.fillRect(x, height - barHeight, barWidth, barHeight);

                x += barWidth + 1; // Add 1 for spacing
            }
        }
        
        // Clean up when page is unloaded
        window.addEventListener('beforeunload', () => {
            if (updateTimeInterval) {
                clearInterval(updateTimeInterval);
            }
        });
    </script>
</body>
</html>