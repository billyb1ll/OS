<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>Music Visualizer</title>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.min.js"></script>
		<style>
			body {
				font-family: Arial, sans-serif;
				display: flex;
				flex-direction: column;
				align-items: center;
				background-color: #f0f0f0; /* Lighter background */
				color: #333;
				padding-top: 20px;
			}
			#player-container {
				width: 600px; /* Match canvas width */
				background-color: #fff; /* White background for the player area */
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
				margin-bottom: 20px;
				border-radius: 8px;
				overflow: hidden; /* Keep elements contained */
			}
			#drop-area,
			#bottom-drop-area {
				border: 2px dashed #ccc;
				padding: 30px;
				width: calc(100% - 64px); /* Adjust width considering padding */
				text-align: center;
				margin: 20px auto; /* Center the drop area */
				color: #666;
				background-color: #fafafa;
				border-radius: 4px;
				display: flex;
				flex-direction: column;
				align-items: center;
			}
			#drop-area {
				padding: 50px 30px;
			}
			.file-upload-btn {
				margin-top: 15px;
				padding: 8px 16px;
				background-color: #4285f4;
				color: white;
				border: none;
				border-radius: 4px;
				cursor: pointer;
				font-size: 14px;
				display: flex;
				align-items: center;
				gap: 5px;
			}
			.file-upload-btn:hover {
				background-color: #3367d6;
			}
			.file-upload-btn::before {
				content: "üìÅ";
			}
			.file-input {
				display: none; /* Hide the native file input */
			}

			/* Test songs section */
			#test-songs-container {
				width: calc(100% - 64px);
				max-width: 800px;
				margin: 10px auto 20px;
				text-align: center;
				padding: 10px 15px 15px;
				background-color: #e8f0fe;
				border-radius: 8px;
				border: 1px solid #c9d6eb;
			}
			#test-songs-container h3 {
				margin: 5px 0 10px;
				font-size: 16px;
				color: #4285f4;
			}
			#test-songs-list {
				display: flex;
				flex-wrap: wrap;
				gap: 8px;
				justify-content: center;
				margin: 0;
				padding: 0;
			}
			.test-song-btn {
				background-color: #4285f4;
				color: white;
				border: none;
				border-radius: 30px;
				padding: 6px 12px;
				cursor: pointer;
				font-size: 13px;
				margin: 5px 0;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
				max-width: 200px;
				transition: all 0.2s ease;
			}
			.test-song-btn:hover {
				background-color: #3367d6;
				transform: scale(1.05);
			}
			.test-song-btn:before {
				content: "üéµ";
				margin-right: 5px;
			}
			#test-songs-loading {
				color: #666;
				font-style: italic;
				margin: 10px 0;
			}

			#canvas {
				display: block; /* Remove extra space below canvas */
				background-color: #000; /* Black background for visualizer */
				width: 100%; /* Make canvas fill container width */
			}
			audio {
				display: none; /* Hide the audio element */
			}
			#status {
				margin-top: 10px;
				font-style: italic;
				color: #666;
				text-align: center;
				width: 100%;
			}
			#controls-bar {
				background-color: #282828; /* Dark background for controls */
				padding: 10px 15px;
				color: #fff;
			}
			#seek-bar-container {
				padding: 5px 0;
			}
			#seek-bar {
				width: 100%;
				cursor: pointer;
				height: 5px; /* Thinner seek bar */
				appearance: none; /* Override default look */
				background: #555; /* Track background */
				border-radius: 3px;
				outline: none;
			}
			/* Style seek bar thumb */
			#seek-bar::-webkit-slider-thumb {
				appearance: none;
				width: 15px;
				height: 15px;
				background: #e50914; /* YouTube-like red */
				border-radius: 50%;
				cursor: pointer;
			}
			#seek-bar::-moz-range-thumb {
				width: 15px;
				height: 15px;
				background: #e50914;
				border-radius: 50%;
				cursor: pointer;
				border: none;
			}

			#main-controls {
				display: flex;
				align-items: center;
				gap: 15px; /* Space between control groups */
				flex-wrap: wrap;
				justify-content: space-between; /* Distribute space */
			}
			.control-group {
				display: flex;
				align-items: center;
				gap: 8px; /* Smaller gap within groups */
			}
			.left-controls,
			.right-controls {
				display: flex;
				align-items: center;
				gap: 15px;
			}
			button {
				padding: 8px 12px; /* Slightly smaller buttons */
				cursor: pointer;
				background-color: transparent; /* Transparent background */
				border: none; /* No border */
				color: #fff; /* White text/icons */
				font-size: 18px; /* Larger font size for icon-like feel */
				border-radius: 4px;
				transition: background-color 0.2s ease;
			}
			button:hover {
				background-color: rgba(255, 255, 255, 0.2); /* Subtle hover effect */
			}
			button:disabled {
				color: #888; /* Dim disabled buttons */
				background-color: transparent;
				cursor: not-allowed;
			}
			/* Specific button styles (optional, could use icons) */
			#play-pause-button::before {
				content: "‚ñ∂";
				margin-right: 5px;
			} /* Simple play icon */
			#play-pause-button.playing::before {
				content: "‚ùö‚ùö";
				margin-right: 5px;
			} /* Simple pause icon */
			#stop-audio-button::before {
				content: "‚ñ†";
				margin-right: 5px;
			} /* Simple stop icon */

			label {
				font-size: 13px;
				margin-right: 0;
				color: #ccc;
			}
			input[type="range"] {
				width: 80px; /* Smaller range inputs */
				height: 4px;
				cursor: pointer;
				appearance: none;
				background: #555;
				border-radius: 2px;
				outline: none;
			}
			input[type="range"]::-webkit-slider-thumb {
				appearance: none;
				width: 12px;
				height: 12px;
				background: #fff; /* White thumb */
				border-radius: 50%;
				cursor: pointer;
			}
			input[type="range"]::-moz-range-thumb {
				width: 12px;
				height: 12px;
				background: #fff;
				border-radius: 50%;
				cursor: pointer;
				border: none;
			}
			.value-display {
				min-width: 35px;
				text-align: right;
				font-size: 13px;
				color: #ccc;
			}
			.time-display {
				font-family: monospace;
				font-size: 14px;
				color: #fff;
			}
			#file-name {
				text-align: center;
				padding: 10px;
				font-size: 16px;
				color: #333;
				background-color: #eee; /* Light background for file name */
				border-bottom: 1px solid #ddd;
			}

			/* Performance monitoring section */
			#performance-monitor {
				width: 600px;
				background-color: #fff;
				border-radius: 8px;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
				margin-bottom: 20px;
				overflow: hidden;
			}
			#performance-header {
				background-color: #3b3b3b;
				color: white;
				padding: 15px;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}
			#performance-title {
				margin: 0;
				font-size: 18px;
			}
			.monitor-section {
				padding: 15px;
				border-bottom: 1px solid #eee;
			}
			.monitor-section h3 {
				margin-top: 0;
				font-size: 16px;
				color: #4285f4;
				margin-bottom: 10px;
			}
			.metrics-row {
				display: flex;
				flex-wrap: wrap;
				gap: 20px;
				margin-bottom: 10px;
			}
			.metric-box {
				background-color: #f9f9f9;
				border-radius: 4px;
				padding: 10px;
				min-width: 150px;
				border-left: 4px solid #4285f4;
			}
			.metric-name {
				font-size: 12px;
				color: #666;
				margin-bottom: 5px;
			}
			.metric-value {
				font-size: 16px;
				font-weight: bold;
				color: #333;
			}
			.server-metric {
				border-left-color: #4285f4; /* Blue for server metrics */
			}
			.client-metric {
				border-left-color: #0f9d58; /* Green for client metrics */
			}
			.network-metric {
				border-left-color: #db4437; /* Red for network metrics */
			}
			.metric-trend {
				font-size: 12px;
				color: #888;
				margin-top: 3px;
				display: flex;
				align-items: center;
			}

			.trend-up {
				color: #db4437;
			}

			.trend-down {
				color: #0f9d58;
			}

			.trend-stable {
				color: #888;
			}

			.trend-up::before {
				content: "‚ñ≤";
				margin-right: 3px;
			}

			.trend-down::before {
				content: "‚ñº";
				margin-right: 3px;
			}

			.trend-stable::before {
				content: "‚ñ†";
				margin-right: 3px;
			}

			.metric-detail {
				font-size: 11px;
				color: #888;
				margin-top: 3px;
			}

			/* Settings panel */
			#visualization-settings {
				width: 800px;
				background-color: #fff;
				border-radius: 8px;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
				margin-bottom: 20px;
				overflow: hidden;
			}
			#settings-header {
				background-color: #3b3b3b;
				color: white;
				padding: 15px;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}
			#settings-title {
				margin: 0;
				font-size: 18px;
			}
			.settings-section {
				padding: 15px;
				border-bottom: 1px solid #eee;
			}
			.settings-section h3 {
				margin-top: 0;
				font-size: 16px;
				color: #4285f4;
				margin-bottom: 10px;
			}
			.setting-row {
				display: flex;
				flex-direction: row;
				align-items: center;
				justify-content: space-between;
				margin-bottom: 15px;
				padding: 10px;
				background-color: #f9f9f9;
				border-radius: 4px;
			}
			.setting-label {
				display: flex;
				flex-direction: column;
			}
			.setting-name {
				font-weight: bold;
				color: #333;
				margin-bottom: 4px;
			}
			.setting-description {
				font-size: 12px;
				color: #666;
			}
			.setting-controls {
				display: flex;
				align-items: center;
				gap: 10px;
			}
			.setting-controls input[type="range"] {
				width: 120px;
			}
			.setting-controls button {
				background-color: #4285f4;
				color: white;
				border: none;
				padding: 8px 12px;
				border-radius: 4px;
				cursor: pointer;
				font-size: 14px;
			}
			.setting-controls button:hover {
				background-color: #3367d6;
			}
			.setting-controls button:disabled {
				background-color: #ccc;
				cursor: not-allowed;
			}
			.color-button {
				width: 30px;
				height: 30px;
				border-radius: 50%;
				cursor: pointer;
				border: 2px solid transparent;
			}
			.color-button.active {
				border: 2px solid white;
				box-shadow: 0 0 0 2px black;
			}
			.color-button.blue-theme {
				background: linear-gradient(to bottom, #4285f4, #0d47a1);
			}
			.color-button.red-theme {
				background: linear-gradient(to bottom, #db4437, #b71c1c);
			}
			.color-button.green-theme {
				background: linear-gradient(to bottom, #0f9d58, #1b5e20);
			}
			.color-button.rainbow-theme {
				background: linear-gradient(
					to right,
					red,
					orange,
					yellow,
					green,
					blue,
					indigo,
					violet
				);
			}
			.network-simulator {
				display: flex;
				flex-direction: column;
				gap: 10px;
			}
			.delay-controls {
				display: flex;
				gap: 10px;
				align-items: center;
			}

			#bottom-drop-area {
				width: 80%; /* Adjust width as needed */
				max-width: 800px; /* Match player width */
				margin: 30px auto; /* Add space above and center */
			}

			/* Flex container for player and performance monitor */
			.flex-container {
				display: flex;
				flex-direction: row;
				gap: 20px;
				width: 100%;
				max-width: 1250px;
				margin: 0 auto;
				justify-content: center;
				flex-wrap: wrap;
			}

			#player-container,
			#performance-monitor {
				flex: 1;
				min-width: 320px;
				max-width: 600px;
			}

			/* Enhanced impact bar styles */
			.impact-bar {
				height: 12px;
				background: linear-gradient(to right, #4285f4, #0d47a1);
				border-radius: 6px;
				transition: width 0.5s ease-in-out;
			}

			.impact-label {
				min-width: 150px;
				font-weight: bold;
				color: #444;
			}

			.impact-value {
				min-width: 80px;
				text-align: right;
				font-size: 13px;
				color: #555;
				font-weight: bold;
			}

			/* Make impact bars colorful based on impact level */
			#resolution-impact {
				background: linear-gradient(to right, #42c6ff, #0d8aff);
			}

			#smoothing-impact {
				background: linear-gradient(to right, #42ff8e, #0d8a4f);
			}

			#chunk-impact {
				background: linear-gradient(to right, #ffdd42, #ff8e0d);
			}

			#network-impact {
				background: linear-gradient(to right, #ff5e42, #d10d0d);
			}

			#viz-style-impact {
				background: linear-gradient(to right, #d442ff, #8e0dff);
			}

			/* Update button styles */
			.impact-test-btn {
				margin-top: 10px;
				background: linear-gradient(to bottom, #4285f4, #2a56c6);
				transition: all 0.3s ease;
				width: 100%;
			}

			.impact-test-btn:hover {
				background: linear-gradient(to bottom, #5294ff, #3367d6);
				transform: translateY(-2px);
			}

			/* Responsive Design */
			@media (max-width: 850px) {
				/* Adjust breakpoint as needed */
				#player-container,
				#performance-monitor,
				#visualization-settings {
					width: 95%; /* Use more width on smaller screens */
				}
				#main-controls {
					flex-direction: column; /* Stack controls vertically */
					align-items: flex-start; /* Align items to the start */
					gap: 10px;
				}
				.left-controls,
				.right-controls {
					width: 100%; /* Make control groups take full width */
					justify-content: space-between; /* Space out items within groups */
				}
				.right-controls {
					flex-direction: column; /* Stack right controls */
					align-items: flex-start;
					gap: 10px;
				}
				.control-group {
					width: 100%;
					justify-content: space-between;
				}
				input[type="range"] {
					width: 150px; /* Give sliders more space */
				}
				#bottom-drop-area {
					width: 90%;
				}
				.file-upload-btn {
					margin-top: 15px;
					padding: 10px 20px;
					font-size: 16px;
				}
				.metrics-row {
					flex-direction: column;
					gap: 10px;
				}
				.metric-box {
					width: calc(100% - 20px);
				}
				.setting-row {
					flex-direction: column;
					align-items: flex-start;
					gap: 10px;
				}
				.setting-controls {
					width: 100%;
					justify-content: space-between;
				}
				.setting-controls input[type="range"] {
					width: 100%;
				}
			}

			@media (max-width: 480px) {
				/* Further adjustments for very small screens */
				h1 {
					font-size: 1.5em;
				}
				#player-container,
				#performance-monitor,
				#visualization-settings {
					width: 100%;
					border-radius: 0;
					box-shadow: none;
				}
				#controls-bar,
				#settings-header,
				#performance-header {
					padding: 10px;
				}
				.left-controls {
					flex-direction: column; /* Stack play/stop/time */
					align-items: flex-start;
					gap: 10px;
				}
				.time-display {
					align-self: flex-start; /* Align time to the start */
				}
				button {
					padding: 10px 15px; /* Slightly larger touch targets */
				}
				label {
					font-size: 12px;
				}
				.value-display {
					font-size: 12px;
				}
				#bottom-drop-area {
					width: 95%;
					padding: 20px;
				}
				/* Make upload button more prominent on mobile */
				.file-upload-btn {
					width: 80%;
					padding: 12px 10px;
					font-size: 16px;
					margin-top: 20px;
				}
				.setting-row {
					padding: 10px 5px;
				}
			}

			footer {
				margin-top: 40px; /* Add space above the footer */
				padding: 15px;
				text-align: center;
				font-size: 12px;
				color: #888;
				width: 100%;
			}

			/* New styles for parameter impact monitor */
			.impact-container {
				display: flex;
				flex-direction: column;
				gap: 10px;
			}
			.impact-row {
				display: flex;
				justify-content: space-between;
				align-items: center;
			}
			.impact-bar-container {
				flex-grow: 1;
				background-color: #eee;
				border-radius: 4px;
				overflow: hidden;
				margin: 0 10px;
			}
			.impact-bar {
				height: 10px;
				background-color: #4285f4;
			}
			.impact-description {
				font-size: 12px;
				color: #666;
				margin-bottom: 5px;
			}
			.impact-test-btn {
				background-color: #4285f4;
				color: white;
				border: none;
				padding: 8px 12px;
				border-radius: 4px;
				cursor: pointer;
				font-size: 14px;
			}
			.impact-test-btn:hover {
				background-color: #3367d6;
			}
			#impact-test-result {
				margin-top: 10px;
				font-style: italic;
				color: #666;
			}
		</style>
	</head>
	<body>
		<h1>Music Visualizer</h1>
		<h5>Recomended: Use Chrome or Firefox</h5>

		<div id="drop-area">
			<p>Drag and drop an MP3 file here</p>
			<label class="file-upload-btn">
				<input type="file" class="file-input" id="file-upload" accept="audio/*" />
				Upload File
			</label>
		</div>

		<div id="test-songs-container">
			<h3>Available Test Songs</h3>
			<div id="test-songs-list">
				<!-- Test song buttons will be dynamically added here -->
			</div>
			<div id="test-songs-loading">Loading test songs...</div>
		</div>

		<!-- New flex container to hold player and performance monitor side by side -->
		<div class="flex-container">
			<div id="player-container">
				<h2 id="file-name">No file playing</h2>
				<!-- File name heading -->
				<canvas id="canvas" width="600" height="300"></canvas>
				<!-- Adjusted width for side-by-side layout -->
				<div id="controls-bar">
					<div id="seek-bar-container">
						<input
							type="range"
							id="seek-bar"
							min="0"
							max="100"
							step="0.1"
							value="0" />
					</div>
					<div id="main-controls">
						<div class="left-controls">
							<button id="play-pause-button" disabled>Play</button>
							<button id="stop-audio-button" disabled>Stop</button>
							<span class="time-display" id="time-display">00:00 / 00:00</span>
						</div>
						<div class="right-controls">
							<div class="control-group">
								<label for="volume-control">Volume:</label>
								<input
									type="range"
									id="volume-control"
									min="0"
									max="1"
									step="0.01"
									value="1" />
								<span class="value-display" id="volume-display">100%</span>
							</div>
							<div class="control-group">
								<label for="speed-control">Speed:</label>
								<input
									type="range"
									id="speed-control"
									min="0.5"
									max="2"
									step="0.1"
									value="1" />
								<span class="value-display" id="speed-display">1.0x</span>
							</div>
							<button id="stop-button">Stop Processing</button>
						</div>
					</div>
				</div>
			</div>

			<!-- Performance Monitoring Panel - now next to the player -->
			<div id="performance-monitor">
				<div id="performance-header">
					<h2 id="performance-title">Performance Monitor</h2>
				</div>

				<div class="monitor-section">
					<h3>Server Performance</h3>
					<div class="metrics-row">
						<div class="metric-box server-metric">
							<div class="metric-name">CPU Usage</div>
							<div class="metric-value" id="cpu-usage">0%</div>
							<div class="metric-trend" id="cpu-trend"></div>
						</div>
						<div class="metric-box server-metric">
							<div class="metric-name">Memory Usage</div>
							<div class="metric-value" id="memory-usage">0 MB</div>
							<div class="metric-trend" id="memory-trend"></div>
						</div>
					</div>
					<div class="metrics-row">
						<div class="metric-box server-metric">
							<div class="metric-name">Avg. Processing Time</div>
							<div class="metric-value" id="processing-time">0 ms</div>
							<div class="metric-detail" id="processing-time-detail">
								Min: 0ms | Max: 0ms
							</div>
						</div>
						<div class="metric-box server-metric">
							<div class="metric-name">Total Chunks Processed</div>
							<div class="metric-value" id="chunks-processed">0</div>
							<div class="metric-detail" id="processing-rate">0 chunks/sec</div>
						</div>
					</div>
				</div>

				<div class="monitor-section">
					<h3>Network Performance</h3>
					<div class="metrics-row">
						<div class="metric-box network-metric">
							<div class="metric-name">Network Latency</div>
							<div class="metric-value" id="network-latency">0 ms</div>
							<div class="metric-detail" id="latency-detail">Min: 0ms | Max: 0ms</div>
						</div>
						<div class="metric-box network-metric">
							<div class="metric-name">Data Received</div>
							<div class="metric-value" id="data-received">0 KB</div>
							<div class="metric-detail" id="bandwidth">0 KB/s</div>
						</div>
					</div>
					<div class="metrics-row">
						<div class="metric-box network-metric">
							<div class="metric-name">Packets Received</div>
							<div class="metric-value" id="packets-received">0</div>
							<div class="metric-detail" id="packets-rate">0/sec</div>
						</div>
						<div class="metric-box network-metric">
							<div class="metric-name">Packets Lost</div>
							<div class="metric-value" id="packets-lost">0</div>
							<div class="metric-detail" id="packet-loss-rate">0%</div>
						</div>
					</div>
				</div>

				<div class="monitor-section">
					<h3>Client Performance</h3>
					<div class="metrics-row">
						<div class="metric-box client-metric">
							<div class="metric-name">Frame Rate</div>
							<div class="metric-value" id="frame-rate">0 FPS</div>
						</div>
						<div class="metric-box client-metric">
							<div class="metric-name">Rendering Time</div>
							<div class="metric-value" id="render-time">0 ms</div>
						</div>
					</div>
					<div class="metrics-row">
						<div class="metric-box client-metric">
							<div class="metric-name">Memory Usage</div>
							<div class="metric-value" id="client-memory">0 MB</div>
						</div>
						<div class="metric-box client-metric">
							<div class="metric-name">Smoothness</div>
							<div class="metric-value" id="smoothness">100%</div>
						</div>
					</div>
				</div>

				<!-- Parameter Impact Monitor moved here -->
				<div class="monitor-section">
					<h3>Parameter Impact</h3>
					<div class="impact-container">
						<!-- Resolution Impact -->
						<div class="impact-row">
							<span class="impact-label">Resolution</span>
							<div class="impact-bar-container">
								<div class="impact-bar" id="resolution-impact" style="width: 0%"></div>
							</div>
							<span class="impact-value" id="resolution-impact-value">0%</span>
						</div>
						<!-- Smoothing Impact -->
						<div class="impact-row">
							<span class="impact-label">Smoothing</span>
							<div class="impact-bar-container">
								<div class="impact-bar" id="smoothing-impact" style="width: 0%"></div>
							</div>
							<span class="impact-value" id="smoothing-impact-value">0%</span>
						</div>
						<!-- Chunk Size Impact -->
						<div class="impact-row">
							<span class="impact-label">Chunk Size</span>
							<div class="impact-bar-container">
								<div class="impact-bar" id="chunk-impact" style="width: 0%"></div>
							</div>
							<span class="impact-value" id="chunk-impact-value">0%</span>
						</div>
						<!-- Network Delay Impact -->
						<div class="impact-row">
							<span class="impact-label">Network Delay</span>
							<div class="impact-bar-container">
								<div class="impact-bar" id="network-impact" style="width: 0%"></div>
							</div>
							<span class="impact-value" id="network-impact-value">0%</span>
						</div>
						<!-- Visualization Style Impact -->
						<div class="impact-row">
							<span class="impact-label">Viz Style</span>
							<div class="impact-bar-container">
								<div class="impact-bar" id="viz-style-impact" style="width: 0%"></div>
							</div>
							<span class="impact-value" id="viz-style-impact-value">0%</span>
						</div>
					</div>

					<button id="run-impact-test-button" class="impact-test-btn">
						Run Impact Test
					</button>
					<div id="impact-test-result">See which parameter has the most impact</div>
				</div>
			</div>
		</div>

		<!-- New Visualization Settings Panel -->
		<div id="visualization-settings">
			<div id="settings-header">
				<h2 id="settings-title">Visualization Settings</h2>
			</div>

			<div class="settings-section">
				<h3>Visual Parameters</h3>

				<div class="setting-row">
					<div class="setting-label">
						<span class="setting-name">Resolution</span>
						<span class="setting-description"
							>Adjust the resolution of the visualizer</span
						>
					</div>
					<div class="setting-controls">
						<input
							type="range"
							id="resolution-control"
							min="64"
							max="512"
							step="32"
							value="256" />
						<span class="value-display" id="resolution-display">256 px</span>
						<button id="resolution-low">Low</button>
						<button id="resolution-high">High</button>
					</div>
				</div>

				<div class="setting-row">
					<div class="setting-label">
						<span class="setting-name">Color Scheme</span>
						<span class="setting-description"
							>Choose visualization color palette</span
						>
					</div>
					<div class="setting-controls">
						<div class="color-button blue-theme active" data-theme="blue"></div>
						<div class="color-button red-theme" data-theme="red"></div>
						<div class="color-button green-theme" data-theme="green"></div>
						<div class="color-button rainbow-theme" data-theme="rainbow"></div>
						<button id="custom-color-btn">Custom Color</button>
						<input type="color" id="color-picker" value="#4285f4" />
					</div>
				</div>

				<div class="setting-row">
					<div class="setting-label">
						<span class="setting-name">Background Color</span>
						<span class="setting-description">Set the visualization background</span>
					</div>
					<div class="setting-controls">
						<input type="color" id="bg-color-picker" value="#000000" />
						<span class="value-display" id="bg-color-display">#000000</span>
					</div>
				</div>

				<div class="setting-row">
					<div class="setting-label">
						<span class="setting-name">Smoothing</span>
						<span class="setting-description">Control visualization smoothness</span>
					</div>
					<div class="setting-controls">
						<input
							type="range"
							id="smoothing-control"
							min="0"
							max="0.9"
							step="0.1"
							value="0.5" />
						<span class="value-display" id="smoothing-display">0.5</span>
					</div>
				</div>

				<div class="setting-row">
					<div class="setting-label">
						<span class="setting-name">Bar Width</span>
						<span class="setting-description"
							>Adjust the width of visualizer bars</span
						>
					</div>
					<div class="setting-controls">
						<input
							type="range"
							id="bar-width-control"
							min="1"
							max="8"
							step="1"
							value="3" />
						<span class="value-display" id="bar-width-display">3px</span>
					</div>
				</div>

				<div class="setting-row">
					<div class="setting-label">
						<span class="setting-name">Visualization Style</span>
						<span class="setting-description">Choose visualization style</span>
					</div>
					<div class="setting-controls">
						<select id="viz-style">
							<option value="bars">Bars</option>
							<option value="wave">Waveform</option>
							<option value="circle">Circular</option>
						</select>
					</div>
				</div>
			</div>

			<div class="settings-section">
				<h3>Performance Parameters</h3>

				<div class="setting-row">
					<div class="setting-label">
						<span class="setting-name">Chunk Size</span>
						<span class="setting-description">Set audio processing chunk size</span>
					</div>
					<div class="setting-controls">
						<button id="chunk-small">Small</button>
						<button id="chunk-medium" class="active">Medium</button>
						<button id="chunk-large">Large</button>
					</div>
				</div>

				<div class="setting-row">
					<div class="setting-label">
						<span class="setting-name">Network Simulation</span>
						<span class="setting-description">Simulate network conditions</span>
					</div>
					<div class="setting-controls network-simulator">
						<div class="delay-controls">
							<label for="network-delay">Delay (ms):</label>
							<input
								type="range"
								id="network-delay"
								min="0"
								max="1000"
								step="50"
								value="0" />
							<span class="value-display" id="delay-display">0ms</span>
						</div>
						<div class="delay-controls">
							<label for="packet-loss">Packet Loss (%):</label>
							<input
								type="range"
								id="packet-loss"
								min="0"
								max="50"
								step="5"
								value="0" />
							<span class="value-display" id="loss-display">0%</span>
						</div>
						<button id="apply-network">Apply</button>
						<button id="reset-network">Reset</button>
					</div>
				</div>
			</div>
		</div>

		<div id="status">Ready</div>
		<audio id="audio"></audio>

		<!-- Bottom drop area for uploading additional songs -->
		<div id="bottom-drop-area">
			<p>Upload more music</p>
			<label class="file-upload-btn">
				<input
					type="file"
					class="file-input"
					id="bottom-file-upload"
					accept="audio/*" />
				Upload File
			</label>
		</div>

		<footer>
			Powered by
			<a href="https://github.com/billyb1ll/OS" label="github">Billy</a
			>@Ratatatamoth group - 2025
		</footer>

		<script>
			const dropArea = document.getElementById("drop-area");
			const bottomDropArea = document.getElementById("bottom-drop-area");
			const canvas = document.getElementById("canvas");
			const ctx = canvas.getContext("2d");
			const audio = document.getElementById("audio");
			const fileNameDisplay = document.getElementById("file-name");
			const statusDisplay = document.getElementById("status");
			const stopButton = document.getElementById("stop-button");
			const playPauseButton = document.getElementById("play-pause-button");
			const stopAudioButton = document.getElementById("stop-audio-button");
			const volumeControl = document.getElementById("volume-control");
			const volumeDisplay = document.getElementById("volume-display");
			const speedControl = document.getElementById("speed-control");
			const speedDisplay = document.getElementById("speed-display");
			const timeDisplay = document.getElementById("time-display");
			const seekBar = document.getElementById("seek-bar");
			const fileUpload = document.getElementById("file-upload");
			const bottomFileUpload = document.getElementById("bottom-file-upload");
			const testSongsContainer = document.getElementById("test-songs-container");
			const testSongsList = document.getElementById("test-songs-list");
			const testSongsLoading = document.getElementById("test-songs-loading");

			// Visualizer settings
			const resolutionControl = document.getElementById("resolution-control");
			const resolutionDisplay = document.getElementById("resolution-display");
			const resolutionLowButton = document.getElementById("resolution-low");
			const resolutionHighButton = document.getElementById("resolution-high");
			const smoothingControl = document.getElementById("smoothing-control");
			const smoothingDisplay = document.getElementById("smoothing-display");
			const barWidthControl = document.getElementById("bar-width-control");
			const barWidthDisplay = document.getElementById("bar-width-display");
			const colorButtons = document.querySelectorAll(".color-button");
			const chunkSizeButtons = document.querySelectorAll(
				"#chunk-small, #chunk-medium, #chunk-large"
			);

			// Network simulation
			const networkDelaySlider = document.getElementById("network-delay");
			const delayDisplay = document.getElementById("delay-display");
			const packetLossSlider = document.getElementById("packet-loss");
			const lossDisplay = document.getElementById("loss-display");
			const applyNetworkButton = document.getElementById("apply-network");
			const resetNetworkButton = document.getElementById("reset-network");

			// Performance metrics elements
			const cpuUsageElement = document.getElementById("cpu-usage");
			const memoryUsageElement = document.getElementById("memory-usage");
			const processingTimeElement = document.getElementById("processing-time");
			const chunksProcessedElement = document.getElementById("chunks-processed");
			const frameRateElement = document.getElementById("frame-rate");
			const renderTimeElement = document.getElementById("render-time");
			const clientMemoryElement = document.getElementById("client-memory");
			const smoothnessElement = document.getElementById("smoothness");
			const networkLatencyElement = document.getElementById("network-latency");
			const dataReceivedElement = document.getElementById("data-received");
			const packetsReceivedElement = document.getElementById("packets-received");
			const packetsLostElement = document.getElementById("packets-lost");

			// Initialize socket.io connection
			const socket = io();

			// App state variables
			let audioContext, analyser, dataArray;
			let isProcessingRemote = false;
			let currentTaskId = null;
			let updateTimeInterval = null;
			let animationFrameId = null;
			let serverChunks = [];
			let performanceMarks = {};
			let allMetrics = []; // Add declaration for allMetrics
			let chunkCounter = 0; // Add counter for processed chunks
			let totalChunks = 0; // Add total chunks expected
			let performanceStats = {
				renderingDuration: [],
				layoutDuration: [],
				paintDuration: [],
				scriptDuration: [],
				taskDuration: [],
				fps: []
			};
			let serverMetrics = {
				cpuUsage: 0,
				memoryUsage: 0,
				processingTimes: [],
				chunksProcessed: 0,
				totalDataReceived: 0,
			};
			let clientMetrics = {
				frameRates: [],
				renderTimes: [],
				lastFrameTime: 0,
				packetLatencies: [],
				packetsReceived: 0,
				packetsLost: 0,
				lostPacketIds: new Set(),
			};
			let visualizerSettings = {
				resolution: 256,
				smoothingFactor: 0.5,
				barWidth: 3,
				colorScheme: "blue",
				chunkSize: "medium",
				networkDelay: 0,
				packetLoss: 0,
			};

			// Settings for color schemes
			const colorSchemes = {
				blue: {
					gradient: function (ctx, height, barHeight) {
						const gradient = ctx.createLinearGradient(
							0,
							height,
							0,
							height - barHeight
						);
						gradient.addColorStop(0, "#4285f4");
						gradient.addColorStop(1, "#a2c4ff");
						return gradient;
					},
					solid: "#4285f4",
				},
				red: {
					gradient: function (ctx, height, barHeight) {
						const gradient = ctx.createLinearGradient(
							0,
							height,
							0,
							height - barHeight
						);
						gradient.addColorStop(0, "#db4437");
						gradient.addColorStop(1, "#ff8a80");
						return gradient;
					},
					solid: "#db4437",
				},
				green: {
					gradient: function (ctx, height, barHeight) {
						const gradient = ctx.createLinearGradient(
							0,
							height,
							0,
							height - barHeight
						);
						gradient.addColorStop(0, "#0f9d58");
						gradient.addColorStop(1, "#a5d6a7");
						return gradient;
					},
					solid: "#0f9d58",
				},
				rainbow: {
					gradient: function (ctx, height, barHeight, i, totalBars) {
						const gradient = ctx.createLinearGradient(
							0,
							height,
							0,
							height - barHeight
						);
						const hue = (i / totalBars) * 360;
						gradient.addColorStop(0, `hsl(${hue}, 100%, 50%)`);
						gradient.addColorStop(1, `hsl(${hue}, 100%, 75%)`);
						return gradient;
					},
					solid: function (i, totalBars) {
						const hue = (i / totalBars) * 360;
						return `hsl(${hue}, 100%, 50%)`;
					},
				},
			};

			// Audio playback controls
			playPauseButton.addEventListener("click", togglePlayPause);
			stopAudioButton.addEventListener("click", stopAudio);
			volumeControl.addEventListener("input", updateVolume);
			speedControl.addEventListener("input", updateSpeed);

			// Settings controls listeners
			resolutionControl.addEventListener("input", updateResolution);
			resolutionLowButton.addEventListener("click", () => {
				resolutionControl.value = 128;
				updateResolution();
			});
			resolutionHighButton.addEventListener("click", () => {
				resolutionControl.value = 512;
				updateResolution();
			});
			smoothingControl.addEventListener("input", updateSmoothing);
			barWidthControl.addEventListener("input", updateBarWidth);

			// Color scheme selection
			colorButtons.forEach((button) => {
				button.addEventListener("click", (e) => {
					const theme = e.target.dataset.theme;
					if (theme) {
						setColorScheme(theme);
						colorButtons.forEach((btn) => btn.classList.remove("active"));
						e.target.classList.add("active");
					}
				});
			});

			// Chunk size selection
			chunkSizeButtons.forEach((button) => {
				button.addEventListener("click", (e) => {
					chunkSizeButtons.forEach((btn) => btn.classList.remove("active"));
					e.target.classList.add("active");
					visualizerSettings.chunkSize = e.target.id.replace("chunk-", "");
				});
			});

			// Network simulation controls
			networkDelaySlider.addEventListener("input", () => {
				visualizerSettings.networkDelay = parseInt(networkDelaySlider.value);
				delayDisplay.textContent = `${visualizerSettings.networkDelay}ms`;
			});

			packetLossSlider.addEventListener("input", () => {
				visualizerSettings.packetLoss = parseInt(packetLossSlider.value);
				lossDisplay.textContent = `${visualizerSettings.packetLoss}%`;
			});

			applyNetworkButton.addEventListener("click", () => {
				// Network settings already stored in visualizerSettings
				statusDisplay.textContent = `Network simulation updated: ${visualizerSettings.networkDelay}ms delay, ${visualizerSettings.packetLoss}% packet loss`;
			});

			resetNetworkButton.addEventListener("click", () => {
				visualizerSettings.networkDelay = 0;
				visualizerSettings.packetLoss = 0;
				networkDelaySlider.value = 0;
				packetLossSlider.value = 0;
				delayDisplay.textContent = "0ms";
				lossDisplay.textContent = "0%";
				statusDisplay.textContent = "Network simulation reset";
			});

			// Load test songs dynamically
			async function loadTestSongs() {
				try {
					const response = await fetch("/test-songs");
					const songs = await response.json();

					if (songs.length === 0) {
						testSongsLoading.textContent = "No test songs available";
						return;
					}

					testSongsLoading.style.display = "none";

					songs.forEach((song) => {
						const button = document.createElement("button");
						button.className = "test-song-btn";
						button.textContent = song.name;
						button.addEventListener("click", () => {
							// Reset audio if already playing
							stopAudio();

							// Update UI
							fileNameDisplay.textContent = `Playing: ${song.name}`;
							statusDisplay.textContent = "Loading test song...";

							// Set audio source
							audio.src = song.url;

							// Enable controls
							playPauseButton.disabled = false;
							stopAudioButton.disabled = false;

							// Initialize audio context before playing
							if (!audioContext) {
								initAudioContext();
							} else {
								// If context already exists but was disconnected, reconnect it
								try {
									if (audioContext.state === "suspended") {
										audioContext.resume();
									}
								} catch (e) {
									console.log("Audio context resume error:", e);
									// If there's an error with existing context, create a new one
									initAudioContext();
								}
							}

							// Wait a bit to ensure resources are loaded, then play
							setTimeout(() => {
								audio
									.play()
									.then(() => {
										statusDisplay.textContent = "Playing test song";
									})
									.catch((err) => {
										console.error("Error playing audio:", err);
										statusDisplay.textContent = `Error: ${err.message}`;
									});
							}, 100);
						});
						testSongsList.appendChild(button);
					});
				} catch (error) {
					console.error("Error loading test songs:", error);
					testSongsLoading.textContent = `Error: ${error.message}`;
				}
			}

			loadTestSongs();

			// Update seek bar as audio plays
			audio.addEventListener("timeupdate", () => {
				if (!audio.duration) return;
				seekBar.value = (audio.currentTime / audio.duration) * 100;
			});

			// Seek to position when user interacts with seek bar
			seekBar.addEventListener("input", () => {
				if (!audio.duration) return;
				audio.currentTime = (seekBar.value / 100) * audio.duration;
			});

			function togglePlayPause() {
				if (audio.paused) {
					audio.play();
					playPauseButton.textContent = "Pause";
					playPauseButton.classList.add("playing");
				} else {
					audio.pause();
					playPauseButton.textContent = "Play";
					playPauseButton.classList.remove("playing");
				}
			}

			function stopAudio() {
				audio.pause();
				audio.currentTime = 0;
				playPauseButton.textContent = "Play";
				playPauseButton.classList.remove("playing");

				// Reset seek bar position
				seekBar.value = 0;
			}

			function updateVolume() {
				audio.volume = volumeControl.value;
				volumeDisplay.textContent = `${Math.round(volumeControl.value * 100)}%`;
			}

			function updateSpeed() {
				audio.playbackRate = speedControl.value;
				speedDisplay.textContent = `${speedControl.value}x`;
			}

			function updateTimeDisplay() {
				if (!audio.duration) return;

				const currentMinutes = Math.floor(audio.currentTime / 60);
				const currentSeconds = Math.floor(audio.currentTime % 60);
				const totalMinutes = Math.floor(audio.duration / 60);
				const totalSeconds = Math.floor(audio.duration % 60);

				timeDisplay.textContent = `${currentMinutes
					.toString()
					.padStart(2, "0")}:${currentSeconds
					.toString()
					.padStart(2, "0")} / ${totalMinutes
					.toString()
					.padStart(2, "0")}:${totalSeconds.toString().padStart(2, "0")}`;
			}

			// Visualizer setting update functions
			function updateResolution() {
				visualizerSettings.resolution = parseInt(resolutionControl.value);
				resolutionDisplay.textContent = `${visualizerSettings.resolution} px`;

				// If we have a running analyser, update its settings
				if (analyser) {
					analyser.fftSize = visualizerSettings.resolution * 2; // FFT size must be 2x resolution
					dataArray = new Uint8Array(analyser.frequencyBinCount);
				}
			}

			function updateSmoothing() {
				visualizerSettings.smoothingFactor = parseFloat(smoothingControl.value);
				smoothingDisplay.textContent =
					visualizerSettings.smoothingFactor.toFixed(1);

				// If we have a running analyser, update its settings
				if (analyser) {
					analyser.smoothingTimeConstant = visualizerSettings.smoothingFactor;
				}
			}

			function updateBarWidth() {
				visualizerSettings.barWidth = parseInt(barWidthControl.value);
				barWidthDisplay.textContent = `${visualizerSettings.barWidth}px`;
			}

			function setColorScheme(scheme) {
				visualizerSettings.colorScheme = scheme;
			}

			// Set up audio events
			audio.addEventListener("play", () => {
				playPauseButton.textContent = "Pause";
				playPauseButton.classList.add("playing");
			});

			audio.addEventListener("pause", () => {
				playPauseButton.textContent = "Play";
				playPauseButton.classList.remove("playing");
			});

			audio.addEventListener("ended", () => {
				playPauseButton.textContent = "Play";
				playPauseButton.classList.remove("playing");
				// Reset seek bar visually
				if (seekBar) {
					seekBar.value = 0;
				}
			});

			audio.addEventListener("loadedmetadata", () => {
				playPauseButton.disabled = false;
				stopAudioButton.disabled = false;
				updateTimeDisplay();

				// Set up interval for updating time display
				if (updateTimeInterval) clearInterval(updateTimeInterval);
				updateTimeInterval = setInterval(updateTimeDisplay, 1000);
			});

			// Socket connection events
			socket.on("connect", () => {
				console.log("Connected to server");
				statusDisplay.textContent = "Connected to server";
			});

			socket.on("disconnect", () => {
				console.log("Disconnected from server");
				statusDisplay.textContent = "Disconnected from server";
				stopButton.disabled = true;
			});

			// Handle incoming audio chunks from server
			socket.on("audio_chunk", (chunkData) => {
				// Apply artificial network delay if set
				if (visualizerSettings.networkDelay > 0) {
					setTimeout(() => processChunk(chunkData), visualizerSettings.networkDelay);
				} else {
					processChunk(chunkData);
				}
			});

			function processChunk(chunkData) {
				// Simulate packet loss if enabled
				if (visualizerSettings.packetLoss > 0) {
					const lossRandom = Math.random() * 100;
					if (lossRandom < visualizerSettings.packetLoss) {
						// Simulated packet loss
						clientMetrics.packetsLost++;
						clientMetrics.lostPacketIds.add(chunkData.metrics.chunk_index);
						packetsLostElement.textContent = clientMetrics.packetsLost;
						return; // Skip processing this chunk
					}
				}

				// Track network metrics
				clientMetrics.packetsReceived++;
				clientMetrics.packetLatencies.push(
					Date.now() - chunkData.metrics.timestamp * 1000
				);
				serverMetrics.totalDataReceived += JSON.stringify(chunkData).length;

				// Store chunk data for visualization
				serverChunks[chunkData.metrics.chunk_index] = chunkData.data;

				// Update server metrics
				serverMetrics.chunksProcessed++;
				serverMetrics.cpuUsage = chunkData.metrics.cpu_usage_after;
				serverMetrics.memoryUsage = chunkData.metrics.memory_usage_after;
				serverMetrics.processingTimes.push(chunkData.metrics.processing_time_ms);

				// Update metrics display
				updateMetricsDisplay();

				// Update metrics on screen
				packetsReceivedElement.textContent = clientMetrics.packetsReceived;
				chunksProcessedElement.textContent = serverMetrics.chunksProcessed;

				// Calculate average latency
				if (clientMetrics.packetLatencies.length > 0) {
					const avgLatency =
						clientMetrics.packetLatencies.reduce((sum, val) => sum + val, 0) /
						clientMetrics.packetLatencies.length;
					networkLatencyElement.textContent = `${Math.round(avgLatency)} ms`;
				}

				// Calculate data received in KB
				dataReceivedElement.textContent = `${Math.round(
					serverMetrics.totalDataReceived / 1024
				)} KB`;
			}

			socket.on("processing_complete", () => {
				console.log("Audio processing complete");
				statusDisplay.textContent = "Audio processing complete";
				isProcessingRemote = false;
				stopButton.disabled = true;
			});

			socket.on("processing_stopped", () => {
				console.log("Audio processing stopped");
				statusDisplay.textContent = "Processing stopped by user";
				isProcessingRemote = false;
				stopButton.disabled = true;
			});

			// Stop button event listener
			stopButton.addEventListener("click", async () => {
				if (!isProcessingRemote || !currentTaskId) return;

				try {
					statusDisplay.textContent = "Stopping processing...";

					const response = await fetch("/stop-processing", {
						method: "POST",
						headers: {
							"Content-Type": "application/json",
						},
						body: JSON.stringify({ task_id: currentTaskId }),
					});

					const result = await response.json();

					if (!response.ok) {
						throw new Error(result.error || "Failed to stop processing");
					}

					console.log("Stop request sent successfully");
					// Wait for the server to confirm via socket
				} catch (error) {
					console.error("Error stopping processing:", error);
					statusDisplay.textContent = `Error: ${error.message}`;
				}
			});

			// Drag and drop event listeners for TOP area
			dropArea.addEventListener("dragover", (event) => {
				event.preventDefault();
				dropArea.style.backgroundColor = "#f0f0f0";
			});

			dropArea.addEventListener("dragleave", () => {
				dropArea.style.backgroundColor = "";
			});

			dropArea.addEventListener("drop", handleDrop);

			async function handleDrop(event) {
				event.preventDefault();
				// Reset background
				dropArea.style.backgroundColor = "";

				// Hide the TOP drop area after a file is dropped
				dropArea.style.display = "none";

				const file = event.dataTransfer.files[0];
				if (!file) return;

				// Display the name of the file
				fileNameDisplay.textContent = `Processing: ${file.name}`;
				statusDisplay.textContent = "Uploading file...";

				// Reset audio controls
				stopAudio();
				playPauseButton.disabled = true;
				stopAudioButton.disabled = true;

				// Reset metrics
				resetMetrics();

				try {
					// Create a FormData object to send the file
					const formData = new FormData();
					formData.append("file", file);
			                          // Add the selected chunk size to the form data
			                          formData.append("chunk_size", visualizerSettings.chunkSize);

					// Upload the file to the server
					const response = await fetch("/upload", {
						method: "POST",
						body: formData,
					});

					if (!response.ok) {
						const errorData = await response.json();
						throw new Error(errorData.error || "Unknown error");
					}

					// Get response data including task ID
					const data = await response.json();
					currentTaskId = data.task_id;

					// Enable stop button now that processing has started
					stopButton.disabled = false;

					// File uploaded successfully
					statusDisplay.textContent = "File uploaded, processing on server...";
					isProcessingRemote = true;

					// Also play locally for the user
					const fileURL = URL.createObjectURL(file);
					audio.src = fileURL;
					fileNameDisplay.textContent = `Playing: ${file.name}`;

					// Initialize Web Audio API for local visualization
					if (!audioContext) {
						initAudioContext();
					}
				} catch (error) {
					console.error("Error:", error);
					statusDisplay.textContent = `Error: ${error.message}`;
					fileNameDisplay.textContent = "Upload failed";
					stopButton.disabled = true;
					playPauseButton.disabled = true;
					stopAudioButton.disabled = true;
				}
			}

			// File upload handling for both top and bottom file inputs
			function handleFileUpload(event) {
				const file = event.target.files[0];
				if (!file) return;

				// Display the name of the file
				fileNameDisplay.textContent = `Processing: ${file.name}`;
				statusDisplay.textContent = "Uploading file...";

				// Reset audio controls
				stopAudio();
				playPauseButton.disabled = true;
				stopAudioButton.disabled = true;

				// Reset metrics
				resetMetrics();

				// Create a FormData object and upload
				uploadFile(file);
			}

			fileUpload.addEventListener("change", handleFileUpload);
			bottomFileUpload.addEventListener("change", handleFileUpload);

			// Common file upload function
			async function uploadFile(file) {
				try {
					// Create a FormData object to send the file
					const formData = new FormData();
					formData.append("file", file);

					// Get the selected chunk size setting from the active button
					let selectedChunkSize = "medium"; // Default
					document.querySelectorAll("#chunk-small, #chunk-medium, #chunk-large").forEach(btn => {
						if (btn.classList.contains("active")) {
							selectedChunkSize = btn.id.replace("chunk-", "");
						}
					});
					formData.append("chunk_size", selectedChunkSize);
					console.log(`Using chunk size: ${selectedChunkSize}`);

					// Update UI to show processing status
					fileNameDisplay.textContent = `Processing: ${file.name}`;
					statusDisplay.textContent = "Uploading file...";

					// Reset metrics
					serverChunks = [];
					allMetrics = [];
					chunkCounter = 0;
					totalChunks = 0;

					// Upload the file to the server
					const response = await fetch("/upload", {
						method: "POST",
						body: formData,
					});

					if (!response.ok) {
						const errorData = await response.json();
						throw new Error(errorData.error || "Unknown error");
					}

					// Get response data including task ID
					const data = await response.json();
					currentTaskId = data.task_id;
					totalChunks = data.chunks || 0;

					// Enable stop button now that processing has started
					stopButton.disabled = false;

					// File uploaded successfully
					statusDisplay.textContent = "File uploaded, processing on server...";
					isProcessingRemote = true;

					// Also play locally for the user
					const fileURL = URL.createObjectURL(file);
					audio.src = fileURL;
					fileNameDisplay.textContent = `Playing: ${file.name}`;

					// Enable audio controls
					playPauseButton.disabled = false;
					stopAudioButton.disabled = false;

					// Initialize Web Audio API for local visualization
					if (!audioContext) {
						initAudioContext();
					}
				} catch (error) {
					console.error("Error:", error);
					statusDisplay.textContent = `Error: ${error.message}`;
					fileNameDisplay.textContent = "Upload failed";
					stopButton.disabled = true;
					playPauseButton.disabled = true;
					stopAudioButton.disabled = true;
				}
			}

			// Function to initialize Web Audio API
			function initAudioContext() {
				try {
					// Create audio context
					if (typeof AudioContext !== 'undefined') {
						audioContext = new AudioContext();
					} else if (typeof webkitAudioContext !== 'undefined') {
						audioContext = new webkitAudioContext(); // For Safari
					} else {
						throw new Error('AudioContext not supported in this browser');
					}

					// Create analyser node
					analyser = audioContext.createAnalyser();
					analyser.fftSize = visualizerSettings.resolution * 2;
					analyser.smoothingTimeConstant = visualizerSettings.smoothingFactor;

					// Create source from audio element
					const source = audioContext.createMediaElementSource(audio);
					source.connect(analyser);
					analyser.connect(audioContext.destination);

					// Create data array for analyser
					dataArray = new Uint8Array(analyser.frequencyBinCount);

					// Start visualization loop
					startVisualization();

					console.log('Audio context initialized successfully');
					return true;
				} catch (error) {
					console.error('Error initializing audio context:', error);
					statusDisplay.textContent = `Error: ${error.message}`;
					return false;
				}
			}

			// Function to reset all metrics
			function resetMetrics() {
				// Reset server metrics
				serverMetrics = {
					cpuUsage: 0,
					memoryUsage: 0,
					processingTimes: [],
					chunksProcessed: 0,
					totalDataReceived: 0
				};

				// Reset client metrics
				clientMetrics = {
					frameRates: [],
					renderTimes: [],
					lastFrameTime: 0,
					packetLatencies: [],
					packetsReceived: 0,
					packetsLost: 0,
					lostPacketIds: new Set()
				};

				// Reset UI elements
				cpuUsageElement.textContent = '0%';
				memoryUsageElement.textContent = '0 MB';
				processingTimeElement.textContent = '0 ms';
				chunksProcessedElement.textContent = '0';
				frameRateElement.textContent = '0 FPS';
				renderTimeElement.textContent = '0 ms';
				clientMemoryElement.textContent = '0 MB';
				smoothnessElement.textContent = '100%';
				networkLatencyElement.textContent = '0 ms';
				dataReceivedElement.textContent = '0 KB';
				packetsReceivedElement.textContent = '0';
				packetsLostElement.textContent = '0';

				// Clear stored data
				serverChunks = [];
				allMetrics = [];
				chunkCounter = 0;
				totalChunks = 0;
			}

			// Function to start visualization
			function startVisualization() {
				// Cancel any existing animation frame
				if (animationFrameId) {
					cancelAnimationFrame(animationFrameId);
				}

				// Update visualization on each frame
				function updateVisualization() {
					// Measure rendering time for performance monitoring
					const startTime = performance.now();

					// Get frequency data from analyser
					analyser.getByteFrequencyData(dataArray);

					// Clear canvas
					ctx.clearRect(0, 0, canvas.width, canvas.height);

					// Calculate bar width and spacing
					const barCount = visualizerSettings.resolution / 2; // Use half the resolution for bar count
					const barWidth = visualizerSettings.barWidth;
					const barSpacing = 1; // Space between bars
					const totalBarWidth = barWidth + barSpacing;
					const canvasWidth = barCount * totalBarWidth;

					// Center the visualization
					const xOffset = (canvas.width - canvasWidth) / 2;

					// Draw bars based on frequency data
					for (let i = 0; i < barCount; i++) {
						// Get height based on frequency data (adjust for visual appeal)
						const barHeight = (dataArray[i] / 255) * canvas.height * 0.8;

						// Calculate x position
						const x = xOffset + i * totalBarWidth;

						// Choose color based on settings
						let color;
						if (visualizerSettings.colorScheme === 'rainbow') {
							color = colorSchemes.rainbow.gradient(ctx, canvas.height, barHeight, i, barCount);
						} else {
							color = colorSchemes[visualizerSettings.colorScheme].gradient(ctx, canvas.height, barHeight);
						}

						// Draw the bar
						ctx.fillStyle = color;
						ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
					}

					// Measure frame time for performance monitoring
					const frameDuration = performance.now() - startTime;
					clientMetrics.renderTimes.push(frameDuration);
					if (clientMetrics.renderTimes.length > 30) clientMetrics.renderTimes.shift();

					// Update frame rate calculation
					const now = performance.now();
					if (clientMetrics.lastFrameTime) {
						const delta = now - clientMetrics.lastFrameTime;
						if (delta > 0) {
							const fps = 1000 / delta;
							clientMetrics.frameRates.push(fps);
							if (clientMetrics.frameRates.length > 30) clientMetrics.frameRates.shift();
						}
					}
					clientMetrics.lastFrameTime = now;

					// Update performance metrics display occasionally
					if (Math.random() < 0.05) { // Only update ~5% of frames to reduce overhead
						updateClientPerformanceMetrics();
					}

					// Continue animation loop
					animationFrameId = requestAnimationFrame(updateVisualization);
				}

				// Start the visualization loop
				updateVisualization();
			}

			// Function to update the performance metrics display
			function updateMetricsDisplay() {
				// Update server metrics
				if (serverMetrics.processingTimes.length > 0) {
					// Calculate average processing time
					const avgTime = serverMetrics.processingTimes.reduce((sum, time) => sum + time, 0) /
						serverMetrics.processingTimes.length;
					processingTimeElement.textContent = `${Math.round(avgTime)} ms`;

					// Calculate min/max processing times
					const minTime = Math.min(...serverMetrics.processingTimes);
					const maxTime = Math.max(...serverMetrics.processingTimes);
					document.getElementById("processing-time-detail").textContent =
						`Min: ${Math.round(minTime)}ms | Max: ${Math.round(maxTime)}ms`;
				}

				// Update CPU and memory usage
				cpuUsageElement.textContent = `${Math.round(serverMetrics.cpuUsage)}%`;
				memoryUsageElement.textContent = `${Math.round(serverMetrics.memoryUsage / 1024 / 1024)} MB`;

				// Update chunks processed
				chunksProcessedElement.textContent = serverMetrics.chunksProcessed;

				// Calculate chunks per second if we have enough data
				const elapsedTime = (Date.now() - clientMetrics.firstChunkTime) / 1000;
				if (elapsedTime > 0 && serverMetrics.chunksProcessed > 0) {
					const rate = serverMetrics.chunksProcessed / elapsedTime;
					document.getElementById("processing-rate").textContent =
						`${rate.toFixed(1)} chunks/sec`;
				}

				// Update network metrics
				if (clientMetrics.packetLatencies.length > 0) {
					// Calculate average, min, max latency
					const avgLatency = clientMetrics.packetLatencies.reduce((sum, val) => sum + val, 0) /
						clientMetrics.packetLatencies.length;
					const minLatency = Math.min(...clientMetrics.packetLatencies);
					const maxLatency = Math.max(...clientMetrics.packetLatencies);

					networkLatencyElement.textContent = `${Math.round(avgLatency)} ms`;
					document.getElementById("latency-detail").textContent =
						`Min: ${Math.round(minLatency)}ms | Max: ${Math.round(maxLatency)}ms`;
				}

				// Calculate data received and bandwidth
				dataReceivedElement.textContent = `${(serverMetrics.totalDataReceived / 1024).toFixed(1)} KB`;
				const elapsedTime2 = (Date.now() - clientMetrics.firstChunkTime) / 1000;
				if (elapsedTime2 > 0) {
					const bandwidthKBps = (serverMetrics.totalDataReceived / 1024) / elapsedTime2;
					document.getElementById("bandwidth").textContent = `${bandwidthKBps.toFixed(1)} KB/s`;
				}

				// Update packets received and rate
				packetsReceivedElement.textContent = clientMetrics.packetsReceived;
				if (elapsedTime2 > 0 && clientMetrics.packetsReceived > 0) {
					const rate = clientMetrics.packetsReceived / elapsedTime2;
					document.getElementById("packets-rate").textContent = `${rate.toFixed(1)}/sec`;
				}

				// Update packet loss metrics
				packetsLostElement.textContent = clientMetrics.packetsLost;
				if (clientMetrics.packetsLost + clientMetrics.packetsReceived > 0) {
					const lossRate = (clientMetrics.packetsLost /
						(clientMetrics.packetsLost + clientMetrics.packetsReceived)) * 100;
					document.getElementById("packet-loss-rate").textContent = `${lossRate.toFixed(1)}%`;
				}
			}

			// Function to update client-side performance metrics
			function updateClientPerformanceMetrics() {
				// Update frame rate display
				if (clientMetrics.frameRates.length > 0) {
					const avgFPS = clientMetrics.frameRates.reduce((sum, fps) => sum + fps, 0) /
						clientMetrics.frameRates.length;
					frameRateElement.textContent = `${Math.round(avgFPS)} FPS`;
				}

				// Update render time display
				if (clientMetrics.renderTimes.length > 0) {
					const avgRenderTime = clientMetrics.renderTimes.reduce((sum, time) => sum + time, 0) /
						clientMetrics.renderTimes.length;
					renderTimeElement.textContent = `${avg```html
					renderTimeElement.textContent = `${avgRenderTime.toFixed(1)} ms`;
				}

				// Update client memory usage (using performance API if available)
				if (window.performance && window.performance.memory) {
					const memoryMB = window.performance.memory.usedJSHeapSize / (1024 * 1024);
					clientMemoryElement.textContent = `${memoryMB.toFixed(0)} MB`;
				}

				// Calculate smoothness based on frame times consistency
				if (clientMetrics.frameRates.length > 5) {
					const frameRates = [...clientMetrics.frameRates];
					const avgFPS = frameRates.reduce((sum, fps) => sum + fps, 0) / frameRates.length;
					const variance = frameRates.reduce((sum, fps) => sum + Math.pow(fps - avgFPS, 2), 0) / frameRates.length;
					const stdDev = Math.sqrt(variance);

					// Smoothness is inversely proportional to standard deviation
					// Lower std dev means more consistent frame rate = smoother
					const smoothness = Math.max(0, 100 - (stdDev / avgFPS) * 100);
					smoothnessElement.textContent = `${Math.min(100, smoothness.toFixed(0))}%`;
				}
			}

			// Function to update the impact bar width and label
			function updateImpactBar(barElement, impactPercentage) {
				// Update bar width
				barElement.style.width = `${impactPercentage}%`;

				// Find the corresponding value element (assumes specific naming pattern)
				const barId = barElement.id;
				const valueElement = document.getElementById(`${barId}-value`);

				// Update value text if element found
				if (valueElement) {
					valueElement.textContent = `${Math.round(impactPercentage)}%`;
				}
			}

			// Initialize first chunk time when the first chunk is received
			socket.on("audio_chunk", (chunkData) => {
				if (!clientMetrics.firstChunkTime) {
					clientMetrics.firstChunkTime = Date.now();
				}
				// Existing chunk processing code continues...
			});

			// Drag and drop event listeners for BOTTOM area
			bottomDropArea.addEventListener("dragover", (event) => {
				event.preventDefault();
				bottomDropArea.style.backgroundColor = "#f0f0f0";
			});

			bottomDropArea.addEventListener("dragleave", () => {
				bottomDropArea.style.backgroundColor = "";
			});

			bottomDropArea.addEventListener("drop", (event) => {
				event.preventDefault();
				// Reset background
				bottomDropArea.style.backgroundColor = "";

				const file = event.dataTransfer.files[0];
				if (!file) return;

				// Process the dropped file
				uploadFile(file);
			});
		</script>
	</body>
</html>
```
